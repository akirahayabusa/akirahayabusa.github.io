<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>maven以及npm依赖查找</title>
      <link href="/2021/08/03/maven-yi-ji-npm-yi-lai-cha-zhao/"/>
      <url>/2021/08/03/maven-yi-ji-npm-yi-lai-cha-zhao/</url>
      
        <content type="html"><![CDATA[<ol><li>maven仓库：<br><a href="https://mvnrepository.com/">mvnrepository</a></li><li>npm仓库：<br><a href="https://www.npmjs.com/">npmjs</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs之npm</title>
      <link href="/2021/08/03/nodejs-zhi-npm/"/>
      <url>/2021/08/03/nodejs-zhi-npm/</url>
      
        <content type="html"><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ol><li>npm工具的使用</li><li>学习express框架使用</li><li>完成留言板案例(express)<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2>能够理解npm的作用<br>能够使用npm安装（添加）第三方模块<br>能够使用npm删除（卸载）第三方模块<br>能够理解package.json文件的作用<br>能够安装moment（日期）第三方模块<br>能够理解模板引擎的作用<br>能够使用npm安装express框架<br>能够使用express建立http服务器<h1 id="1-npm简介"><a href="#1-npm简介" class="headerlink" title="1.npm简介"></a>1.npm简介</h1></li><li>是什么？<br>是一个命令行工具（node package manager）</li><li>能干吗？<br>下载node所需要的第三方模块</li><li>安装Node js自带npm所以直接使用<h1 id="2-NPM语法"><a href="#2-NPM语法" class="headerlink" title="2.NPM语法"></a>2.NPM语法</h1><h2 id="2-1命令"><a href="#2-1命令" class="headerlink" title="2.1命令"></a>2.1命令</h2></li><li>查看：npm list</li><li>安装：npm install  模块或@版本号 [安装可选参数]</li><li>卸载：npm uninstall 模块<h2 id="2-2安装参数"><a href="#2-2安装参数" class="headerlink" title="2.2安装参数"></a>2.2安装参数</h2></li><li>–save 记录生产环境所需模块（默认）</li><li>–save-dev 记录开发环境所需模块</li><li>-g 该模块可在命令行运行 (global)     npm config list查看全局目录所在位置<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多学一招：</span><br><span class="line">都安装:npminstall</span><br><span class="line">只安装生产环境:npm install --production</span><br></pre></td></tr></tbody></table></figure><h1 id="3-NPM使用"><a href="#3-NPM使用" class="headerlink" title="3.NPM使用"></a>3.NPM使用</h1><h2 id="3-1初体验"><a href="#3-1初体验" class="headerlink" title="3.1初体验"></a>3.1初体验</h2></li><li>复习：MIME是一个规则，类型text/html-.html文件、image/png-png文件等</li><li>需求：安装mime模块 （ps.该模块用户判断mime类型）</li></ol><hr><ol><li>明确：npm是nodejs项目模块管理工具</li><li>使用：1-初始化项目，2-安装/卸载模块</li></ol><hr><ol><li>步骤1：初始化项目（ps.自动创建package.json文件，作用：描述项目一依赖）<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></tbody></table></figure></li><li>步骤2：安装<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [xxx]</span><br></pre></td></tr></tbody></table></figure></li><li>步骤3：使用<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.引入第三方模块</span><br><span class="line">var mime = require('mime');</span><br><span class="line"> </span><br><span class="line">//2.调用方法测试</span><br><span class="line">var img = 'xxxx.png';</span><br><span class="line">var imgMimeType = mime.getType(img);</span><br><span class="line">var imgType = mime.getExtension(imgMimeType);</span><br><span class="line">console.log(imgMimeType);     </span><br><span class="line">console.log(imgType);  </span><br></pre></td></tr></tbody></table></figure><h2 id="3-2安装参数作用"><a href="#3-2安装参数作用" class="headerlink" title="3.2安装参数作用"></a>3.2安装参数作用</h2></li></ol><ul><li><p>发现1：上面默认不加任何参数安装mime，命令行不可以直接使用</p></li><li><p>解 决：加上-g重新安装</p></li></ul><p><img src="/medias/article/nodejs/wps1.jpg" alt="img"> </p><ul><li>发现2：默认install不加参数则属于生成环境模块</li></ul><p><img src="/medias/article/nodejs/wps2.jpg" alt="img"> </p><ul><li>测试：参数–save-dev代表开发环境</li></ul><p><img src="/medias/article/nodejs/wps3.jpg" alt="img"> </p><ul><li>发现3：安装模块加–production参数则生产环境，否则全部安装</li></ul><p><img src="/medias/article/nodejs/wps4.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps5.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps6.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps7.jpg" alt="img"> </p><h1 id="4-npm模块版本控制"><a href="#4-npm模块版本控制" class="headerlink" title="4.npm模块版本控制"></a>4.npm模块版本控制</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">科普软件版本含义：</span><br><span class="line">aplha版   - 内测版（功能不全，BUG多）</span><br><span class="line">beta版    - 公测版（功能不全，发骚友准备，依旧存在BUG）</span><br><span class="line">rc版      - 预览版（功能不再增加）</span><br><span class="line">stable版  - 用户可用</span><br><span class="line">===================</span><br><span class="line">主版本号.次版本号.修改版本号</span><br><span class="line"></span><br><span class="line">主版本：功能模块有大的变动，比如增加多个模块或者整体架构发生变化</span><br><span class="line">次版本：次版本号的升级对应的只是局部的变动</span><br><span class="line">修改版：BUG修复或者功能的扩充等</span><br><span class="line"></span><br><span class="line">~用户使用该版本后，最多升级到【修改版】最新</span><br><span class="line">^用户使用该版本后，最多升级到【次版本】最新</span><br><span class="line">*用户使用该版本后，可以升级到最新版本</span><br></pre></td></tr></tbody></table></figure><h1 id="5-npm源管理"><a href="#5-npm源管理" class="headerlink" title="5.npm源管理"></a>5.npm源管理</h1><ul><li>明确：通过npm命令下载会到国外服务器获取</li><li>缺点：下载速度慢</li><li>解决：切换国内服务器</li></ul><hr><ul><li><p>简介：nrm是资源管理工具，可以切换国内服务器下载</p></li><li><p>命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装：npm install nrm -g</span><br><span class="line">查看：nrm ls              （注：单词list缩写，查看可用服务器）</span><br><span class="line">切换：nrm use 服务器名</span><br><span class="line">测速：nrm test</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用</p><ol><li>步骤1：安装</li></ol><p><img src="/medias/article/nodejs/wps8.jpg" alt="img"> </p><ol start="2"><li>步骤2：查看 -&gt; 测速 -&gt; 切换 -&gt; 验证</li></ol><p><img src="/medias/article/nodejs/wps9.jpg" alt="img"> </p></li></ul><h1 id="6-NPM自定义脚本命令-重点-难点"><a href="#6-NPM自定义脚本命令-重点-难点" class="headerlink" title="6.NPM自定义脚本命令(重点.难点)"></a>6.NPM自定义脚本命令(重点.难点)</h1><ul><li><p>思考：后期启动项目需要敲很长的命令，如何简化？</p></li><li><p>解决：通过修改package.json文件的scripts自定义脚本命令</p></li></ul><hr><ul><li><p>语法：npm  run 名称    （ps. 1-名称指scripts中的键 2-如果是start则run可省略）</p></li><li><p>练习：运行a输出666</p></li></ul><p><img src="/medias/article/nodejs/wps10.jpg" alt="img"> </p><ul><li>练习：通过start运行mime_test.js文件</li></ul><p><img src="/medias/article/nodejs/wps11.jpg" alt="img"> </p><h1 id="7-NPM包自定义包发布（理解）"><a href="#7-NPM包自定义包发布（理解）" class="headerlink" title="7.NPM包自定义包发布（理解）"></a>7.NPM包自定义包发布（理解）</h1><p>模块：在node中就是一个文件<br>包：N个模块、目录、package.json等组成，然后发布，让别人require</p><hr><p>需 求：发布itcast-php-teacher包</p><ul><li>步骤1：创建day22开发目录 -&gt; 初始化 -&gt; 修改package.json文件</li></ul><p><img src="/medias/article/nodejs/wps12.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fn = {</span><br><span class="line"></span><br><span class="line">​name: 'phpopenfather',</span><br><span class="line"></span><br><span class="line">​school: 'php@itcast',</span><br><span class="line"></span><br><span class="line">​say: function() {</span><br><span class="line"></span><br><span class="line">​console.log('悟空');</span><br><span class="line"></span><br><span class="line">​}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module.exports = fn</span><br></pre></td></tr></tbody></table></figure><ul><li><p> 步骤2：打开npmjs.com注册账号</p></li><li><p>步骤3：本地登录提交（切记提交自己的包必须切换到国外服务器，下载在切换过来）</p></li></ul><p><img src="/medias/article/nodejs/wps13.jpg" alt="img"> </p><ul><li>步骤4：测试（创建day23开发目录，执行命令npm install itcast-php-teacher）</li></ul><p><img src="/medias/article/nodejs/wps14.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps15.jpg" alt="img"> </p><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><p>什么是NMP：就是一个工具，用于管理项目所需依赖</p><p>语法：npm install/uninstall 模块/包（ps. -g命令行执行/全局目录  –save-dev开发环境）</p><p>服务器加速：通过nrm工具</p><p>自定义脚本命令：修改package.json的scripts键即可</p><p>自定义发布：node login  &amp;  node publish </p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01nodejs入门</title>
      <link href="/2021/08/01/nodejs-ru-men/"/>
      <url>/2021/08/01/nodejs-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="1-初体验（REPL）"><a href="#1-初体验（REPL）" class="headerlink" title="1.初体验（REPL）"></a>1.初体验（REPL）</h1><ol><li>R(read) 读取（读取用户输入的代码）</li><li>E(exec) 执行 （执行用户输入的代码）</li><li>P(print) 打印（打印用户输入的js代码）</li><li>L(loop) 循环 (后续所有js代码执行都会循环以上命令)</li><li>退出：ctrl+c<h2 id="1-1通过命令行运行js代码"><a href="#1-1通过命令行运行js代码" class="headerlink" title="1.1通过命令行运行js代码"></a>1.1通过命令行运行js代码</h2></li><li>命令行输入node启动node后直接输入js代码</li><li>命令行node xx.js运行js文件<br>（cls清屏）<h1 id="2-模块系统"><a href="#2-模块系统" class="headerlink" title="2.模块系统"></a>2.模块系统</h1>js三大组成部分：</li><li>ecmascript(声明js变量，判断，循环等语法)</li><li>dom(document)</li><li>BOM(window，local等)<br>模块(http服务器等)<h2 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h2><h2 id="2-1-1使用Nodejs编写应用程序主要使用"><a href="#2-1-1使用Nodejs编写应用程序主要使用" class="headerlink" title="2.1.1使用Nodejs编写应用程序主要使用"></a>2.1.1使用Nodejs编写应用程序主要使用</h2></li></ol><ul><li>ecmascript语法：变量、判断、循环等（js三大组成部分：ECMA/DOM/BOM）</li><li>内置核心模块：http服务、fs文件操作、url路径、path路径处理、os操作系统</li><li>第三方模块：</li><li>自定义模块：自己创建的js文件<h2 id="2-2-2CommonJS模块模范"><a href="#2-2-2CommonJS模块模范" class="headerlink" title="2.2.2CommonJS模块模范"></a>2.2.2CommonJS模块模范</h2></li><li>一个文件就是一个模块</li><li>通过require来加载模块</li><li>通过exports和modul.exports来到导出模块中的成员（声明模块中哪些功能可以使用）<h2 id="2-2自定义Node-js模块"><a href="#2-2自定义Node-js模块" class="headerlink" title="2.2自定义Node.js模块"></a>2.2自定义Node.js模块</h2><h2 id="2-2-1语法"><a href="#2-2-1语法" class="headerlink" title="2.2.1语法"></a>2.2.1语法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">步骤1：导出成员（声明模块中/文件中哪些方法可以被外部使用）</span><br><span class="line">//写法1</span><br><span class="line">exports.属性/方法名=功能</span><br><span class="line">//写法2</span><br><span class="line">module.exports.属性/方法名=变量名</span><br><span class="line">步骤2：外部引入使用</span><br><span class="line">//使用：先引入再调用</span><br><span class="line">var 对象=require('路径及文件名')</span><br><span class="line">对象.属性或方法名</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img src="/medias/article/nodejs/image-20210801202634827.png" alt="image-20210801202634827"></p><h2 id="2-3第三方模块"><a href="#2-3第三方模块" class="headerlink" title="2.3第三方模块"></a>2.3第三方模块</h2><h2 id="2-4Node-js内置模块"><a href="#2-4Node-js内置模块" class="headerlink" title="2.4Node.js内置模块"></a>2.4Node.js内置模块</h2><p><a href="https://github.com/nodejs/node/tree/master/lib">内置模块</a><br><a href="http://nodejs.cn/api/">api手册</a></p><h3 id="2-4-1获取操作系统信息（os模块）-–了解"><a href="#2-4-1获取操作系统信息（os模块）-–了解" class="headerlink" title="2.4.1获取操作系统信息（os模块）  –了解"></a>2.4.1获取操作系统信息（os模块）  –了解</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 字节是计算机中的一种计量单位，表示数据量的多少 </span><br><span class="line">// 1字节（Byte）= 8位（bit）</span><br><span class="line">// 1KB = 1024Byte（字节）</span><br><span class="line">// 1MB = 1024KB</span><br><span class="line">// 1GB =  1024MB</span><br><span class="line">// 1TB =  1024GB</span><br><span class="line"></span><br><span class="line">//1.创建os对象（引入nodejs内置os模块）</span><br><span class="line">var os = require("os");</span><br><span class="line">//2.调用os对象方法获取系统数据</span><br><span class="line">console.log('hello，另起一行' + os.EOL    + 'itcast');</span><br><span class="line">console.log('主机名: ' + os.hostname());</span><br><span class="line">console.log('操作系统名: '  + os.type());</span><br><span class="line">console.log('操作系统平台: ' + os.platform());</span><br><span class="line">console.log('内存总量: '  + os.totalmem() + " 字节.");</span><br><span class="line">console.log('空闲内存: '  + os.freemem() + " 字节.");</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-2路径处理（path模块）"><a href="#2-4-2路径处理（path模块）" class="headerlink" title="2.4.2路径处理（path模块）"></a>2.4.2路径处理（path模块）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//dirname  去最后一个</span><br><span class="line">//basename 取最后一个</span><br><span class="line"></span><br><span class="line">//1.创建path对象（引入nodejs内置path模块）</span><br><span class="line">var path = require("path");</span><br><span class="line">//2.调用path对象方法</span><br><span class="line">var testData = 'c:/app/view/godos/add.html';</span><br><span class="line">console.log(path.extname(testData)); //取后缀（包括.）</span><br><span class="line">console.log(path.basename(testData));//取最后一层</span><br><span class="line">console.log(path.dirname(testData)); //去最后一层</span><br><span class="line">console.log(path.dirname(path.dirname(testData)));</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-3网址处理（url模块）"><a href="#2-4-3网址处理（url模块）" class="headerlink" title="2.4.3网址处理（url模块）"></a>2.4.3网址处理（url模块）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.创建url对象（引入nodejs内置url模块）</span><br><span class="line">var url = require("url");</span><br><span class="line">//2.调用url对象方法</span><br><span class="line">var wangzhi = "http://itcast.cn?name=张三&amp;age=18";</span><br><span class="line">console.log(url.parse(wangzhi)); //解析网址</span><br><span class="line">console.log(url.parse(wangzhi, true)); //解析网址参数为对象</span><br><span class="line"></span><br><span class="line">var param = url.parse(wangzhi, true).query;</span><br><span class="line">console.log(param);</span><br><span class="line">console.log(param.name);</span><br><span class="line">console.log(param.age);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-4文件处理（fs模块）"><a href="#2-4-4文件处理（fs模块）" class="headerlink" title="2.4.4文件处理（fs模块）"></a>2.4.4文件处理（fs模块）</h3><h4 id="2-4-4-1写入文件"><a href="#2-4-4-1写入文件" class="headerlink" title="2.4.4.1写入文件"></a>2.4.4.1写入文件</h4><p>语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1.创建fs对象（引入node内置的fs模块）</span><br><span class="line">var fs = require('fs');</span><br><span class="line"></span><br><span class="line">//2.调用函数写数据进文件</span><br><span class="line">fs.writeFile(路径及文件名，数据，function(err){</span><br><span class="line">    err  为null - 则写入成功</span><br><span class="line">    err不为null - 则写入失败</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>练习：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1.创建fs对象（引入node内置的fs模块）</span><br><span class="line">var fs = require('fs');</span><br><span class="line"></span><br><span class="line">//2.调用函数写数据进文件</span><br><span class="line">fs.writeFile('./a.txt', '你好，hybs', function(err) {</span><br><span class="line">    // err  为null - 则写入成功</span><br><span class="line">    // err不为null - 则写入失败</span><br><span class="line">    if (err) {</span><br><span class="line">    console.log(err);</span><br><span class="line">    return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    console.log('写入成功');</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-4-2读取文件"><a href="#2-4-4-2读取文件" class="headerlink" title="2.4.4.2读取文件"></a>2.4.4.2读取文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile('../../data/data01.txt', 'utf-8', function(err,data) {    //不加解码类型会是buffer对象</span><br><span class="line">    // err  为null - 则写入成功</span><br><span class="line">    // err不为null - 则写入失败</span><br><span class="line">    if (err) {</span><br><span class="line">        console.log(err);</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">    console.log(data)</span><br><span class="line">    console.log('读取成功');</span><br><span class="line">    console.log(data.toString())   //通过buffer.tostring()转化为string类型</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-5引入http服务器并创建服务器"><a href="#2-4-5引入http服务器并创建服务器" class="headerlink" title="2.4.5引入http服务器并创建服务器"></a>2.4.5引入http服务器并创建服务器</h3><ol><li>创建http服务器<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//说明</span><br><span class="line">//nodejs作用：1-提供JS运行环境，2-提供N多模块(API)让JS更强大</span><br><span class="line"></span><br><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求</span><br><span class="line">server.on('request', function() {</span><br><span class="line">console.log('收到客户端请求了');</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li>响应数据<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求（形参：request-请求对象，response-响应对象）</span><br><span class="line">server.on('request', function(request, response) {</span><br><span class="line">//有请求DOS窗口就输出</span><br><span class="line">console.log('收到客户端请求了，请求路径是：' + request.url);</span><br><span class="line">//响应请求</span><br><span class="line">//write方法：声明给客户端发送的数据</span><br><span class="line">//end方法：  结束响应</span><br><span class="line">response.write('hello,');</span><br><span class="line">response.write('itcast');</span><br><span class="line">response.end();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li>响应不同数据<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求（形参：request-请求对象，response-响应对象）</span><br><span class="line">server.on('request', function(request, response) {</span><br><span class="line"></span><br><span class="line">//获取请求路径（注：默认请求站点根目录）</span><br><span class="line">var url = request.url;</span><br><span class="line">//判断请求路径</span><br><span class="line">if (url == '/') {</span><br><span class="line">var content = 'this is index';</span><br><span class="line">} else if (url == '/login') {</span><br><span class="line">var content = 'this is login';</span><br><span class="line">} else {</span><br><span class="line">var content = '404 Not Found';</span><br><span class="line">}</span><br><span class="line">//响应请求</span><br><span class="line">response.write(content);</span><br><span class="line">response.end();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li>解决中文乱码<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//说明</span><br><span class="line">//nodejs作用：1-提供JS运行环境，2-提供N多模块(API)让JS更强大</span><br><span class="line"></span><br><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求（形参：request-请求对象，response-响应对象）</span><br><span class="line">server.on('request', function(request, response) {</span><br><span class="line"></span><br><span class="line">//响应请求</span><br><span class="line">response.setHeader('Content-Type', 'text/html; charset=utf-8');</span><br><span class="line">response.write("哥哥来抓我呀，&lt;a href='http://nn.com'&gt;点击进入我的世界&lt;/a&gt;");</span><br><span class="line">response.end();</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-6请求和响应对象"><a href="#2-4-6请求和响应对象" class="headerlink" title="2.4.6请求和响应对象"></a>2.4.6请求和响应对象</h3></li><li>请求对象<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.headers     获取请求头信息（对象）</span><br><span class="line">req.rawHeaders 获取请求头信息（数组）</span><br><span class="line">req.httpVersion 获取HTTP版本</span><br><span class="line">req.method获取请求方法</span><br><span class="line">req.url         获取请求路径（注：不含网址）</span><br></pre></td></tr></tbody></table></figure></li><li>响应对象<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res.statusCode = 404;</span><br><span class="line">res.statusMessage = 'Not Found';</span><br><span class="line">res.setHeader（'Content-Type', 'text/html; charset=utf-8'）</span><br><span class="line"></span><br><span class="line">//简化版</span><br><span class="line">res.writeHeader(404, 'Not Found', {</span><br><span class="line">'Content-Type' : 'text/html; charset=utf8'</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">res.write（数据）</span><br><span class="line">res.end()</span><br></pre></td></tr></tbody></table></figure>（响应应查看mime类型）<h2 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h2></li><li>es6标签替换<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var html1=``;</span><br><span class="line">    msgs.forEach(function (items) {</span><br><span class="line">        html1+=`&lt;li class="list-group-item"&gt;${items.name}：${items.content} &lt;span class="pull-right"&gt;${items.create_at}&lt;/span&gt;&lt;/li&gt;`</span><br><span class="line"></span><br><span class="line">    })</span><br><span class="line">    lg.innerHTML=html1</span><br></pre></td></tr></tbody></table></figure></li><li>传统标签替换<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> var eleLi="";</span><br><span class="line">   for (var i=0;i&lt;msgs.length;i++){</span><br><span class="line"></span><br><span class="line">       eleLi+="&lt;li class='list-group-item'&gt;"+msgs[i].name+'说：'+msgs[i].content+" &lt;span class='pull-right'&gt;"+msgs[i].create_at+"&lt;/span&gt;&lt;/li&gt;"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   }</span><br><span class="line">lg.innerHTML=eleLi</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01微信小程序介绍及环境准备</title>
      <link href="/2021/07/30/01-wei-xin-xiao-cheng-xu-jie-shao-ji-huan-jing-zhun-bei/"/>
      <url>/2021/07/30/01-wei-xin-xiao-cheng-xu-jie-shao-ji-huan-jing-zhun-bei/</url>
      
        <content type="html"><![CDATA[<h1 id="1-微信小程序介绍"><a href="#1-微信小程序介绍" class="headerlink" title="1.微信小程序介绍"></a>1.微信小程序介绍</h1><p>微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可以使用的应用，它实现了应用“触手可及的梦想”，用户扫一扫或搜一下即可以打开应用。</p><h2 id="1-1为什么使用微信小程序"><a href="#1-1为什么使用微信小程序" class="headerlink" title="1.1为什么使用微信小程序"></a>1.1为什么使用微信小程序</h2><ol><li>微信有海量用户，而且黏性很高，在微信里开发产品更容易触达用户。</li><li>推广app或公众号成本太高。</li><li>开发适配成本低。</li><li>容易小规模是错，然后快速迭代。</li><li>跨平台。<h2 id="1-2微信小程序"><a href="#1-2微信小程序" class="headerlink" title="1.2微信小程序"></a>1.2微信小程序</h2>作者：张小龙</li><li>1.9正式上限。<h2 id="1-3不容忽视的其他微信小程序"><a href="#1-3不容忽视的其他微信小程序" class="headerlink" title="1.3不容忽视的其他微信小程序"></a>1.3不容忽视的其他微信小程序</h2></li><li>支付宝小程序</li><li>百度小程序</li><li>qq小程序</li><li>今日头条+抖音小程序</li></ol><h1 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h1><p>开发微信小程序之前，必须准备好相应的环境。</p><h2 id="2-1注册账号"><a href="#2-1注册账号" class="headerlink" title="2.1注册账号"></a>2.1注册账号</h2><p><a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1&amp;token=&amp;lang=zh_CN">小程序注册</a></p><h2 id="2-2获取APPID"><a href="#2-2获取APPID" class="headerlink" title="2.2获取APPID"></a>2.2获取APPID</h2><h2 id="2-3开发工具"><a href="#2-3开发工具" class="headerlink" title="2.3开发工具"></a>2.3开发工具</h2><h1 id="10-常见组件"><a href="#10-常见组件" class="headerlink" title="10.常见组件"></a>10.常见组件</h1><p>小程序中常用的布局组件：<br><code>view,text,rich-text,button,image,navigator,icon,swiper,radio,checkbox.</code>等</p><h2 id="10-1view"><a href="#10-1view" class="headerlink" title="10.1view"></a>10.1view</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;&lt;view hover-class="h-class"&gt;</span><br><span class="line"> 点击我试试</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="10-2text"><a href="#10-2text" class="headerlink" title="10.2text"></a>10.2text</h2><ol><li>文本标签</li><li>只能嵌套text</li><li>长按文字可以复制（只有该标签有这个功能selectable）</li><li>可以对空格 回车进行编码(decode可以解析的有 &nbsp; &lt; &gt; &amp; '    )<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &nbsp;&lt;text selectable="{{false}}" decode="{{false}}"&gt;</span><br><span class="line"> &nbsp; 普&amp;nbsp;通</span><br><span class="line"> &nbsp;&lt;/text&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="10-3image"><a href="#10-3image" class="headerlink" title="10.3image"></a>10.3image</h2>好用的图床：<a href="https://qr.maitube.com/#pic%E6%88%96%E4%B8%83%E7%89%9B%E4%BA%91">https://qr.maitube.com/#pic或七牛云</a></li></ol><p><a href="https://m.360buyimg.com/mobilecms/s1350x1350_jfs/t3070/50/2589172055/70494/6e7056c5/57e3482aNa6324a7c.jpg!q70.dpg.webp">https://m.360buyimg.com/mobilecms/s1350x1350_jfs/t3070/50/2589172055/70494/6e7056c5/57e3482aNa6324a7c.jpg!q70.dpg.webp</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03php基础之环境搭建</title>
      <link href="/2021/07/30/03php-ji-chu-zhi-huan-jing-da-jian/"/>
      <url>/2021/07/30/03php-ji-chu-zhi-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02php基础之网站基本概念</title>
      <link href="/2021/07/29/02php-ji-chu-zhi-wang-zhan-ji-ben-gai-nian/"/>
      <url>/2021/07/29/02php-ji-chu-zhi-wang-zhan-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="1-网站基本概念"><a href="#1-网站基本概念" class="headerlink" title="1.网站基本概念"></a>1.网站基本概念</h1><h2 id="1-服务器概念"><a href="#1-服务器概念" class="headerlink" title="1.服务器概念"></a>1.服务器概念</h2><p>​        服务器(server)，也称伺服器，是提供计算服务地设备，由于服务器需要相应服务请求，并进行处理，因此一般来说服务器应具备承担服务并保障服务的能力。<br>​        服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力，稳定性，可靠性，安全性，可扩展性，可管理性等方面要求较高。<br>​        在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，web服务器等。<br>服务器：能够提供服务的机器，取决于机器上安装的服务软件。<br>Web服务器：tomcat,jetty,iis等。</p><h2 id="2-IP概念"><a href="#2-IP概念" class="headerlink" title="2.IP概念"></a>2.IP概念</h2><p>​        IP: Internet Protocol,网络之间互联协议。网络之间互联的协议也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现像红心的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互联互通，IP地址具有唯一性。</p><h2 id="3-域名"><a href="#3-域名" class="headerlink" title="3.域名"></a>3.域名</h2><p>​        域名（Domain name）是由遗传用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名指带有行政自主权的一个地方区域），域名是一个IP地址的“面具”。一个域名的目的是便于记忆和沟通的一组服务器地址，域名作为力所能及难忘的互联网参与者的名称。<br>特殊ip:127.0.0.1 代表本机<br>特殊域名：localhost 代表本机</p><h2 id="4-DNS"><a href="#4-DNS" class="headerlink" title="4.DNS"></a>4.DNS</h2><p>​        DNS（Domain name system，域名系统），因特网上作为域名和ip地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住ip，通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><h2 id="5-端口"><a href="#5-端口" class="headerlink" title="5.端口"></a>5.端口</h2><p>​        端口（port）,可以认为是设备与外界通讯交流的出口，端口可以分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口；物理端口又称为接口，是可见端口，如计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。<br>端口用来区分服务。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01php基础之php简介</title>
      <link href="/2021/07/29/01php-ji-chu-zhi-php-jian-jie/"/>
      <url>/2021/07/29/01php-ji-chu-zhi-php-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="php简介"><a href="#php简介" class="headerlink" title="php简介"></a>php简介</h2><h3 id="什么是php"><a href="#什么是php" class="headerlink" title="什么是php"></a>什么是php</h3><p>​       php定义：一种服务器端的HTML脚本/编程语言，是一种简单的，面向对象的，解释型的，健壮的，安全的，性能非常之高的，独立于架构的，可移植的，动态的脚本语言，是一种广泛用于Open Source（开源）的尤其适合Web开发并可以嵌入HTML的多用途脚本语言。它的语法接近C，java和Perl,而且容易学习。该语言让Web开发人员快速的书写动态生成的网页。<br>php前身：Personal HomePage,个人主页，使用Perl语言开发的一种写个人主页的语言，<br>php:PHP Hypertext preprosessor,php超本文预处理器，底层使用c语言。</p><h3 id="PHP发展史"><a href="#PHP发展史" class="headerlink" title="PHP发展史"></a>PHP发展史</h3><p>Rasmus Lerdorf:创建者<br>平台支持（window,Linux,UNIX）<br>数据库支持（Sqlserver,mysql,Oracle,Access）</p><h3 id="静态网站与动态网站的区别"><a href="#静态网站与动态网站的区别" class="headerlink" title="静态网站与动态网站的区别"></a>静态网站与动态网站的区别</h3><p>静态网站：web1.0时代<br>动态网站：web2.0时代</p><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><p>​      website的中文名是网站，是指在互联网上，根据一定的规则，使用HTML、PHP等代码语言制作的用于展示特定内容的相关网页的集合，有可供管理人员操作的后台及用户使用的前台。简单地说，Webside是一种通讯工具，就像布告栏一样，人们可以通过 网站来发布自己想要公开的咨询，或者利用Website来提供相关的网络服务。人们可以通过网页浏览器来访问网站，获取自己现需要的咨询或者享受网络服务。</p><h4 id="静态网站的特点"><a href="#静态网站的特点" class="headerlink" title="静态网站的特点"></a>静态网站的特点</h4><p>​      1.网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；<br>​      2.静态网页的内容相对稳定，因此容易被搜索引擎检索；<br>​      3.静态网页没有数据库的支持；在网站制作和维护方面工作量较大，因此档网站信息量很大时完全依靠静态网页制作方式比较困难；<br>​      4.静态网页的交互性交叉，在功能方面有较大的限制；</p><h4 id="动态网站的特点"><a href="#动态网站的特点" class="headerlink" title="动态网站的特点"></a>动态网站的特点</h4><p>​      1.交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流地桥梁，动态网页地交互性也是今后web发展地潮流。<br>​      2.自动更新：即无须手动更新HTML文档，便会自动生成新页面，可以大大节省工作量。<br>​      3.因时因人而变：即当不同时间、不同用户访问同一网址会出现不同地信息。<br>​      此外动态网页是与静态网页相对应地，也就是说，网页URL的后缀不是.htm,html,shtml,xml等静态网页常见形式，而是以.asp，jsp,php,perl,cgi等为形式为后缀，在动态网页网址中有一个标志地符号–”?”。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语音转文字服务推荐与简单使用</title>
      <link href="/2021/07/27/yu-yin-zhuan-wen-zi-fu-wu-tui-jian-yu-jian-dan-shi-yong/"/>
      <url>/2021/07/27/yu-yin-zhuan-wen-zi-fu-wu-tui-jian-yu-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-服务"><a href="#1-服务" class="headerlink" title="1.服务"></a>1.服务</h1><h2 id="1-阿里云"><a href="#1-阿里云" class="headerlink" title="1.阿里云"></a>1.阿里云</h2><p>进入阿里云&gt;搜索产品（智能语音交互）&gt;选择个性化人声定制&gt;定制声音即可。<br>链接:<a href="https://nls-portal.console.aliyun.com/overview">个性化人声定制</a></p><h2 id="2-微软Azure"><a href="#2-微软Azure" class="headerlink" title="2.微软Azure"></a>2.微软Azure</h2><p>进入微软&gt;点击产品&gt;点击认知服务&gt;语音&gt;文本转语音。<br>链接：<a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/text-to-speech/?cdn=disable#overview">个性化人声定制</a></p><h1 id="2-好用的工具"><a href="#2-好用的工具" class="headerlink" title="2.好用的工具"></a>2.好用的工具</h1><h2 id="1-AI配音专家"><a href="#1-AI配音专家" class="headerlink" title="1.AI配音专家"></a>1.AI配音专家</h2><p>链接：<a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/text-to-speech/?cdn=disable#overview">AI配音专家</a><br>建议版本=v1.1.0<br>AccessKey ID=’LTAI5tCjZCecgfxbYTrktNpt’<br>AccessKey Secret=’eDX04dZrQ0XLCBIyVPpX4yDa1L17Na’<br>appkey = ‘9mPeplUpc60EzB3r’;</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式课程介绍</title>
      <link href="/2021/07/21/she-ji-mo-shi-ke-cheng-jie-shao/"/>
      <url>/2021/07/21/she-ji-mo-shi-ke-cheng-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1.设计模式概述"></a>1.设计模式概述</h1><h2 id="1-1软件设计模式的产生背景"><a href="#1-1软件设计模式的产生背景" class="headerlink" title="1.1软件设计模式的产生背景"></a>1.1软件设计模式的产生背景</h2><p>​       “设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h2><p>​        软件设计模式（software design pattern），又称为设计模式，是一套被反复使用、多数人知晓、经过分类编目的、代码设计经验的总结。它描述了再软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一些列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>​        设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合欢喜的充分理解。<br>​        正确使用设计模式具有以下优点：  </p><ol><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，是软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。<h2 id="1-4设计模式分类"><a href="#1-4设计模式分类" class="headerlink" title="1.4设计模式分类"></a>1.4设计模式分类</h2></li><li>创建型模式<br>​       用于描述”怎样创建对象“，它的主要特点是”将对象的创建和使用分离“。GOF(四人组)书中提供了单例、原型、工厂方法、抽象工厂、建造者等5种创建型模式。</li><li>结构型模式<br>​       用于描述如何将类或对象按照布局组成更大的结构，GOF书中提供了代理、适配器、桥接、装饰、外观、享元、组合等7种结构型模式。</li><li>行为型模式<br>​       用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GOF书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为型模式。<h1 id="2-UML"><a href="#2-UML" class="headerlink" title="2.UML"></a>2.UML</h1>​      统一建模语言（unified modeling language,uml）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态和静态信息。<br>​       uml从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图。<h2 id="2-1类图概述"><a href="#2-1类图概述" class="headerlink" title="2.1类图概述"></a>2.1类图概述</h2>​       类图（class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。<h2 id="2-2类图的作用"><a href="#2-2类图的作用" class="headerlink" title="2.2类图的作用"></a>2.2类图的作用</h2>​       在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解。<br>​       类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。<h2 id="2-3类图表示法"><a href="#2-3类图表示法" class="headerlink" title="2.3类图表示法"></a>2.3类图表示法</h2><h3 id="2-3-1类的表示方式"><a href="#2-3-1类的表示方式" class="headerlink" title="2.3.1类的表示方式"></a>2.3.1类的表示方式</h3>​       在uml类图中，类使用包含类名、属性（field）和方法（method）且带有分割线的矩形来表示，比如下图表示一个employee类,它包含name,age和address这三个属性以及work（）方法。<br><img src="/medias/article/20210725/image-20210722224556025.png" alt="image-20210722224556025"><br>​      属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，uml类图中表示可见性的符号有三种：</li></ol><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected<br>​      属性的完整表示方式是：可见性 名称 ：类型 [=缺省值]<br>​      方法的完整表示方法是：可见性 名称（参数列表）[：返回类型]<blockquote><ul><li>中括号中的内容是可选的</li><li>也有将类型放在变量名前面，返回值类型放在方法名前面</li></ul></blockquote></li></ul><h3 id="2-3-2类与类之间关系的表示方式"><a href="#2-3-2类与类之间关系的表示方式" class="headerlink" title="2.3.2类与类之间关系的表示方式"></a>2.3.2类与类之间关系的表示方式</h3><h4 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h4><p>​      关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、丈夫与妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系，聚合关系和组合关系。<br>​      一般关联又可以分为单向关联，双向关联，自关联。</p><ol><li><p>单向关联<br><img src="/medias/article/20210725/image-20210722230359533.png" alt="image-20210722230359533"><br>​      在uml类图中单向关联用一个带箭头的实线表示。上图表示每一个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p></li><li><p>双向关联<br> <img src="/medias/article/20210725/image-20210722233858276.png" alt="image-20210722233858276"><br>​      在UML类图中，双向关联用一个不带箭头的直线表示。上图中在customer类中维护一个List<product>,表示一个用户可以购买多个商品，在product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</product></p></li><li><p>自关联</p></li></ol><p><img src="/medias/article/20210725/image-20210722234348752.png" alt="image-20210722234348752"><br>​     自关联在uml类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是”自己包含自己“。</p><h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p>​      聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。<br>​      聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。<br>​      在UML类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><img src="/medias/article/20210725/image-20210723104522458.png" alt="image-20210723104522458"></p><h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>​      组合关系表示类之间的整体与部分的关系，但它十一种更强烈的聚合关系。<br>​      在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也不存在，部分对象不能脱离整体对象而存在。如头和嘴的关系，没有了头，嘴也就不存在了。<br>​      在UML类图中，组合关系用带实心零星的线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><img src="/medias/article/20210725/image-20210723104534564.png" alt="image-20210723104534564"></p><h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>​     依赖关系是一种使用关系，他是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法是通过局部变量，方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。<br>​     在UML类图中：依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：<br><img src="/medias/article/20210725/image-20210723105511797.png" alt="image-20210723105511797"></p><h4 id="2-3-2-5继承关系"><a href="#2-3-2-5继承关系" class="headerlink" title="2.3.2.5继承关系"></a>2.3.2.5继承关系</h4><p>​    继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。<br>​     在uml类图中，泛化关系用带空心三角箭头的实现来表示，箭头从子类指向父类。在代码实现时，使用面向对象的机制来实现泛化关系。例如，Student类和Teacher类都是Person类的子类，其类图如下所示：<br><img src="/medias/article/20210725/image-20210723114954142.png" alt="image-20210723114954142"></p><h4 id="2-3-2-6实现关系"><a href="#2-3-2-6实现关系" class="headerlink" title="2.3.2.6实现关系"></a>2.3.2.6实现关系</h4><p>​    实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。<br>​    在UML类图中，实现关系使用带空心三角建瓯的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下所示：<br><img src="/medias/article/20210725/image-20210723115455894.png" alt="image-20210723115455894"></p><h1 id="3-软件设计原则"><a href="#3-软件设计原则" class="headerlink" title="3.软件设计原则"></a>3.软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="3-1开闭原则"><a href="#3-1开闭原则" class="headerlink" title="3.1开闭原则"></a>3.1开闭原则</h2><p>​     <strong>对扩展开放，对修改关闭。</strong>在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔效果。简言之，是为了使程序的扩展性好，易于维护和升级。<br>​     为了达到这样的效果，我们需要使用到接口和抽象类。<br>​     因为抽象类灵活性好，适应性广，只要抽象合理，可以基本保持软件架构的稳定，而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。<br>下面以<code>搜狗拼音输入法</code>皮肤为例介绍开闭原则的应用。<br>​     【例子】<code>搜狗拼音输入法</code>的皮肤设计。<br>​     分析：<code>搜狗拼音输入法</code>的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点可以为其定义一个抽象类（AbstractSkin)。而每个具体的皮肤（RyuHayabusaSkin）是其子类。用户窗体可以根据需要选择或增加新的主题，而需要修改原代码，所以它是满足开闭原则的。</p><p><img src="/medias/article/20210725/image-20210724221234379.png" alt="image-20210724221234379"></p><p>（注：图中搜狗输入法与抽象皮肤类之间的关系是聚合，画错了）</p><h2 id="3-2里氏代换原则"><a href="#3-2里氏代换原则" class="headerlink" title="3.2里氏代换原则"></a>3.2里氏代换原则</h2><p>​     里氏代换原则是面向对象设计的基本原则之一。<br>​     里氏代换原则：任何积累可以出现的地方。子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加心得方法完成新增功能外，尽量不要重写父类的方法。<br>​     如果通过重写父类的来完成新的功能，这样写起来虽然简单，但是整体继承体系的可复用性会比较差，或者是运用多态比较频繁时，程序运行出错的概率会比较大。<br>​     经典例子：<br>【例】正方形不是长方形<br>​     在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发一个几何图形相关的软件系统，可以顺理成章的让正方形继承自矩形。</p><p><img src="/medias/article/20210725/image-20210728234327425.png" alt="image-20210728234327425"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaee面试题</title>
      <link href="/2021/06/02/javaee-kao-qian-fu-xi-da-gang/"/>
      <url>/2021/06/02/javaee-kao-qian-fu-xi-da-gang/</url>
      
        <content type="html"><![CDATA[<h1 id="考点范围"><a href="#考点范围" class="headerlink" title="考点范围"></a>考点范围</h1><h2 id="1-http常见的状态码以及这些状态码的意义"><a href="#1-http常见的状态码以及这些状态码的意义" class="headerlink" title="1. http常见的状态码以及这些状态码的意义"></a>1. http常见的状态码以及这些状态码的意义</h2><blockquote><p>   <strong>2开头：（请求成功）表示成功处理了请求的状态代码</strong></p><ul><li>200：（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li><li>201：（已创建）请求成功并且服务器创建了新的资源</li><li>202：（已接受）服务器已接受请求，但尚未处理</li><li>203：（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一资源。</li><li>204：（无内容）服务器成功处理了请求，但没有返回任何内容</li><li>205：（重置内容）服务器成功处理了请求，但没有返回任何内容</li><li>206：（部分内容）服务器成功处理了部分 GET 请求</li></ul><p>   <strong>3开头：（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向</strong></p><ul><li>300：（多种选择）针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li><li>301：（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新的位置</li><li>302：（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303：（查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>304：（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页内容</li><li>305：（使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li><li>307：（临时重定向）服务器目前从不同位置的网页响应请求，但请求者继续使用原有位置来进行以后的请求</li></ul><p>   <strong>4开头：（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</strong></p><ul><li>400：（错误请求）服务器不理解请求的语法</li><li>401：（未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li><li>403：（禁止）服务器拒绝请求</li><li>404：（未找到）服务器找不到请求的网页</li><li>405：（方法禁用）禁用请求中指定的方法</li><li>406：（不接受）无法使用请求的内容特性响应请求的网页</li><li>407：（需要代理授权）此状态代码与 401 （未授权）类似，但指定请求者应当授权使用代理</li><li>408：（请求超时）服务器等候请求时发生超时</li><li>409：（冲突）服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息</li><li>410：（已删除）如果请求的资源已永久删除，服务器就会返回此响应</li><li>411：（需要有效长度）服务器不接受不含有效内容长度标头字段的请求</li><li>412：（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件</li><li>413：（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力</li><li>414：（请求的 URI 过长）请求的URI（通常为网址）过长，服务器无法处理</li><li>415：（不支持的媒体类型）请求的格式不受请求页面的支持</li><li>416：（请求范围不符合）如果页面无法提供请求的范围，则服务器返回此状态代码</li><li>417：（未满足期望值）服务器未满足“期望”请求标头字段要求</li></ul><p>   <strong>5开头：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</strong></p><ul><li>500：（服务器内部错误）服务器遇到错误，无法完成请求</li><li>501：（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li><li>502：（错误网关）服务器作为网关或代理，从上游服务器收到无效响应</li><li>503：（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态</li><li>504：（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505：（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本</li></ul></blockquote><h2 id="2-SpringBoot常用注解有哪些、"><a href="#2-SpringBoot常用注解有哪些、" class="headerlink" title="2. SpringBoot常用注解有哪些、"></a>2. SpringBoot常用注解有哪些、</h2><blockquote><p>   <strong>1、@SpringBootApplication</strong></p><p>   这个注解是Spring Boot最核心的注解，用在 Spring Boot的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。实际上这个注解是@Configuration,@EnableAutoConfiguration,@ComponentScan三个注解的组合。由于这些注解一般都是一起使用，所以Spring Boot提供了一个统一的注解@SpringBootApplication。</p><p>   <strong>2、@EnableAutoConfiguration</strong></p><p>   允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p><p>   如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。</p><p>   @EnableAutoConfiguration实现的关键在于引入了AutoConfigurationImportSelector，其核心逻辑为selectImports方法，逻辑大致如下：</p><p>   　●　从配置文件META-INF/spring.factories加载所有可能用到的自动配置类；</p><p>   　●　去重，并将exclude和excludeName属性携带的类排除；</p><p>   　●　过滤，将满足条件（@Conditional）的自动配置类返回；</p><p>   <strong>3、@Configuration</strong></p><p>   用于定义配置类，指出该类是 Bean 配置的信息源，相当于传统的xml配置文件，一般加在主类上。如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><p>   <strong>4、@ComponentScan</strong></p><p>   组件扫描。让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p>   @ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring容器中。</p><p>   <strong>5、@Repository</strong></p><p>   用于标注数据访问组件，即DAO组件。</p><p>   使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><p>   <strong>6、@Service</strong></p><p>   一般用于修饰service层的组件</p><p>   <strong>7、@RestController</strong></p><p>   用于标注控制层组件(如struts中的action)，表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器；它是@Controller和@ResponseBody的合集。</p><p>   <strong>8、@ResponseBody</strong></p><p>   表示该方法的返回结果直接写入HTTP response body中</p><p>   一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p><p>   <strong>9、@Component</strong></p><p>   泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>   <strong>10、@Bean</strong></p><p>   相当于XML中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>   <strong>11、@AutoWired</strong></p><p>   byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。</p><p>   当加上（required=false）时，就算找不到bean也不报错。</p><p>   <strong>12、@Qualifier</strong></p><p>   当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用</p><p>   <strong>13、@Resource(name=”name”,type=”type”)</strong></p><p>   没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>   <strong>14、@RequestMapping</strong></p><p>   RequestMapping是一个用来处理请求地址映射的注解；提供路由信息，负责URL到Controller中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>   <strong>15、@RequestParam</strong></p><p>   用在方法的参数前面。</p><p>   @Transactional：事务注解</p></blockquote><h2 id="3-ArrayList集合Set集合的区别"><a href="#3-ArrayList集合Set集合的区别" class="headerlink" title="3. ArrayList集合Set集合的区别"></a>3. ArrayList集合Set集合的区别</h2><blockquote><p>   <strong><em>\</em>1.List*****</strong>*集合是有序存储*<strong>**</strong>*,Set*<strong>**</strong>*集合是无序存储。这里的有序和无序针对的是存储地址来说的。****</p><p>   <strong><em>\</em>2.List*****</strong>*可以存储重复的值，*<strong>**</strong>*Set*<strong>**</strong>*不可以存储重复的值.****</p></blockquote><h2 id="4-SpringBoot常见的场景启动器有哪些"><a href="#4-SpringBoot常见的场景启动器有哪些" class="headerlink" title="4. SpringBoot常见的场景启动器有哪些"></a>4. SpringBoot常见的场景启动器有哪些</h2><blockquote><p>   ##1. spring-boot-starter-parent（控制版本信息）</p><p>   ##2. spring-boot-starter-web</p><p>   ##3. spring-boot-starter-test</p><p>   ##4.mybatis-spring-boot-starter</p><p>   ##5. mysql-connector-java：</p></blockquote><h2 id="5-描述servlet的生命周期"><a href="#5-描述servlet的生命周期" class="headerlink" title="5. 描述servlet的生命周期"></a>5. 描述servlet的生命周期</h2><blockquote><p>   <strong><em>①当启动,请求第一次到达servlet资源的时候,这个servlet对象一旦被构建,那么会立即去调用init方法,并且只会调用1次.</em></strong></p><p>   ②service方法 - 负责接收和响应来自于客户端的请求和数据.</p><p>   ③当关闭容器的时候,在**<em>GC**</em>销毁这个servlet对象之前,会先调用destroy方法来进行一些收尾的工作.</p></blockquote><h2 id="6-Servlet中service方法和doGet方法以及doPost方法的使用场景"><a href="#6-Servlet中service方法和doGet方法以及doPost方法的使用场景" class="headerlink" title="6. Servlet中service方法和doGet方法以及doPost方法的使用场景"></a>6. Servlet中service方法和doGet方法以及doPost方法的使用场景</h2><blockquote><p>   <strong><em>推荐学习阶段直接使用service - 接受一切请求</em></strong></p><ol><li>doGet方法只能接受get请求,否则会抛出HTTP Status 405 - HTTP method POST is not supported by this URL</li><li>doPost方法只能post请求 - 否则会抛出HTTP Status 405 - HTTP method GET is not supported by this URL</li><li>service：可以处理get请求和post请求<br>doGet：只能处理get请求<br>doPost：只能处理post请求<br>当service方法存在时，不管是post请求，还是get请求，都会优先调用service方法进行处理<br>如果service不存在时，根据各自的请求方式对doGet方法和doPost方法进行调用</li></ol></blockquote><h2 id="7-HttpServletRequest和HttpResponse以及ServletConfig三者的作用"><a href="#7-HttpServletRequest和HttpResponse以及ServletConfig三者的作用" class="headerlink" title="7. HttpServletRequest和HttpResponse以及ServletConfig三者的作用"></a>7. HttpServletRequest和HttpResponse以及ServletConfig三者的作用</h2><blockquote></blockquote><h2 id="8-Tomcat和Nginx服务器的默认端口号分别是什么"><a href="#8-Tomcat和Nginx服务器的默认端口号分别是什么" class="headerlink" title="8. Tomcat和Nginx服务器的默认端口号分别是什么"></a>8. Tomcat和Nginx服务器的默认端口号分别是什么</h2><blockquote><p>   8080     N:80</p></blockquote><h2 id="9-Http协议是什么-Http的结构是什么"><a href="#9-Http协议是什么-Http的结构是什么" class="headerlink" title="9. Http协议是什么?Http的结构是什么?"></a>9. Http协议是什么?Http的结构是什么?</h2><blockquote><p>   http(Hypertext transfer protocol)超文本传输协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定</p><p>   协议版本 + 状态码 + 用于解释状态码的原因短语 + 可选的响应首部字段 + 实体主体</p><p>   <strong>请求行、请求头、请求体</strong></p></blockquote><h2 id="10-jsp九大内置对象有哪些"><a href="#10-jsp九大内置对象有哪些" class="headerlink" title="10. jsp九大内置对象有哪些"></a>10. jsp九大内置对象有哪些</h2><blockquote><pre><code>1. out - 输出内容到web网页2. **page - page作用域,生命周期 - 仅仅在当前页面中有效**3. **request - request作用域,HttpServletRequest对象.一次请求一次响应**4. **session - session作用域,一次会话期间,从浏览器打开 - 浏览器完全退出**5. **application - application作用域 - 对应servlet中的ServletContext作用域,从服务器启动 - 服务器关闭**6. response - 将所有的响应给客户端的信息全部封装到了这个对象中.7. config - 获取servlet的配置信息 - 对应servlet中的组件ServletConfig对象8. exception - 异常对象9. pageContext - 通过这个对象可以获取比如page,request,session,application,config等对象.</code></pre></blockquote><h2 id="11-servlet三大作用域分别是什么-它们的作用域范围是什么"><a href="#11-servlet三大作用域分别是什么-它们的作用域范围是什么" class="headerlink" title="11. servlet三大作用域分别是什么,它们的作用域范围是什么"></a>11. servlet三大作用域分别是什么,它们的作用域范围是什么</h2><blockquote><pre><code>**1.request**作用域：一次请求**2.session**　作用域：当前会话。ServletContext 作用域 - 从服务器启动 - 服务器关闭</code></pre></blockquote><h2 id="12-如何防止表单重复提交"><a href="#12-如何防止表单重复提交" class="headerlink" title="12. 如何防止表单重复提交"></a>12. 如何防止表单重复提交</h2><blockquote><pre><code>1、禁掉提交按钮表单提交后使用 Javascript 使提交按钮disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效了。2、Post/Redirect/Get 模式在提交后执行页面重定向，这就是所谓的 Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。 3、在 session 中存放一个特殊标志当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。这使你的 web 应用有了更高级的 XSRF 保护。 4、使用Cookie处理使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单。 5、在数据库里添加约束在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。</code></pre></blockquote><h2 id="13-什么是cookie-有什么特点"><a href="#13-什么是cookie-有什么特点" class="headerlink" title="13. 什么是cookie,有什么特点"></a>13. 什么是cookie,有什么特点</h2><blockquote><pre><code>ookie是存储于访问者计算机中的变量 cookie是浏览器提供的一种机制 可以由JavaScript对其进行控制(设置、读取、删除)**简单但功能强大****跟踪cookie检测****安全数据删除****全面的cookie控制**（1）cookie可能被禁用； （2）cookie与浏览器相关，不能互相访问； （3）cookie可能被用户删除； （4）cookie安全性不够高； （5）cookie存储空间很小(只有4–10KB左右)</code></pre></blockquote><h2 id="14-什么是session-使用方式"><a href="#14-什么是session-使用方式" class="headerlink" title="14. 什么是session,使用方式"></a>14. 什么是session,使用方式</h2><blockquote><pre><code>当用户请求来自应用程序的 Web页时，服务器会给每一个用户（浏览器）创建一个Session对象；在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中；当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去，默认情况下，只要浏览器没有关闭，这个Session就一直存在。</code></pre></blockquote><h2 id="15-SpringBoot优势有哪些"><a href="#15-SpringBoot优势有哪些" class="headerlink" title="15. SpringBoot优势有哪些"></a>15. SpringBoot优势有哪些</h2><blockquote><pre><code># **更快速的构建能力**# **起步依赖**# **内嵌容器支持**# **Actuator 监**控非常简洁的安全策略集成支持关系数据库和非关系数据库支持运行期内嵌容器，如 Tomcat、Jetty强大的开发包，支持热启动自动管理依赖自带应用监控</code></pre></blockquote><h2 id="16-get请求和post请求有什么区别"><a href="#16-get请求和post请求有什么区别" class="headerlink" title="16. get请求和post请求有什么区别"></a>16. get请求和post请求有什么区别</h2><blockquote><pre><code>2） get是从服务器上获取数据，post是向服务器传送数据，一般用于更新资源信息3） get请求时通过URL直接请求数据，数据信息可以在URL中直接看到，比如浏览器访问；而post请求是放在请求头中的，我们是无法直接看到的4） get提交有数据大小的限制，一般是不超过2KB，而POST理论上默认是没有限制5） get请求因为数据参数是暴露在URL中的，所以安全性比较低，如密码不能暴露的就不能用get请求；post请求中，请求信息是放在请求头的，安全性较高，可以使用。&gt; 1. get请求 - 着重于去查询,请求参数的长度是有限制的&gt;    * 直接在浏览器中输入url&gt;    * 超链接的方式&gt;    * js按钮 - window.location&gt; 2. post请求 - 着重于去insert,update,delete - 请求参数的长度理论是没有限制的,二进制数据,安全&gt;    * form表单中的method设置成了post</code></pre></blockquote><h2 id="17-session和cookie有什么区别"><a href="#17-session和cookie有什么区别" class="headerlink" title="17. session和cookie有什么区别"></a>17. session和cookie有什么区别</h2><blockquote><pre><code>- **Cookie是把用户的数据写给用户的浏览器，由浏览器保存，可以保存多个**- **cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗**- **cookie的有效期在cookie生成的时候设置进去。**- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中  Session是把用户的数据写进用户独占的session中，服务器保存,登陆信息等重要信息存放入session  如果主要考虑到安全应当使用session ；  Session的有效期在web.xml配置文件里设置  </code></pre></blockquote><h2 id="18-转发和重定向有什么区别-以及代码是如何实现的"><a href="#18-转发和重定向有什么区别-以及代码是如何实现的" class="headerlink" title="18. 转发和重定向有什么区别,以及代码是如何实现的"></a>18. 转发和重定向有什么区别,以及代码是如何实现的</h2><blockquote><pre><code>##转发&gt; 地址栏的地址不变&gt;&gt; 一次请求,共享request作用域中数据&gt;&gt; 发生在服务器端的跳转##重定向&gt; 地址栏会变 -&gt;&gt; 控制台network - 出现俩次请求 - 不能获取到request作用域中的数据&gt;&gt; 本质:永远是拿着新的地址重新从客户端再次发送新的请求&gt;&gt; 发生在客户端的跳转转发：request.getRequestDispatcher("success.jsp").forward(request,response);           重定向：response.sendRedirect("success.jsp");</code></pre></blockquote><h2 id="19-反向代理和正向代理有什么区别"><a href="#19-反向代理和正向代理有什么区别" class="headerlink" title="19. 反向代理和正向代理有什么区别"></a>19. 反向代理和正向代理有什么区别</h2><blockquote><pre><code>**正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.****反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端**</code></pre></blockquote><h2 id="20-nginx的负载均衡策略有哪些"><a href="#20-nginx的负载均衡策略有哪些" class="headerlink" title="20. nginx的负载均衡策略有哪些"></a>20. nginx的负载均衡策略有哪些</h2><blockquote><pre><code>| 轮询               | 默认方式        || ------------------ | --------------- || weight             | 权重方式        || ip_hash            | 依据ip分配方式  || least_conn(待定)   | 最少连接方式    || fair（第三方）     | 响应时间方式    || url_hash（第三方） | 依据URL分配方式 |</code></pre></blockquote><h2 id="21-jstl中的c标签的使用-c-if-c-foreach等"><a href="#21-jstl中的c标签的使用-c-if-c-foreach等" class="headerlink" title="21. jstl中的c标签的使用 - c:if,c:foreach等"></a>21. jstl中的c标签的使用 - c:if,c:foreach等</h2><blockquote><pre><code>&lt;c:forEach var="u" items="${us}"&gt;&lt;tr&gt;&lt;td&gt;${u.uname}&lt;/td&gt;&lt;td&gt;${u.upsw}&lt;/td&gt;&lt;td&gt;${u.ugrant}&lt;/td&gt;&lt;td&gt;&lt;a href="edit?id=${u.id }" class="easyui-linkbutton" data-options="iconCls:'icon-reload'"&gt;更新&lt;/a&gt;&lt;/td&gt;&lt;c:if test="${u.uname!=uname}"&gt;&lt;td&gt;&lt;a href="delete?id=${u.id }&amp;uname=${u.uname}" οnclick="javascript:return del();" class="easyui-linkbutton" data-options="iconCls:'icon-remove'"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/c:if&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre></blockquote><h2 id="22-什么是多线程-什么是单例"><a href="#22-什么是多线程-什么是单例" class="headerlink" title="22. 什么是多线程,什么是单例"></a>22. 什么是多线程,什么是单例</h2><blockquote><pre><code>多线程，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</code></pre></blockquote><h2 id="23-Redis中的缓存穿透-击穿-雪崩是什么意思"><a href="#23-Redis中的缓存穿透-击穿-雪崩是什么意思" class="headerlink" title="23. Redis中的缓存穿透,击穿,雪崩是什么意思"></a>23. Redis中的缓存穿透,击穿,雪崩是什么意思</h2><blockquote><pre><code>**缓存雪崩：**缓存雪崩是指在设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，导致所有的查询都落在数据库上，造成了缓存雪崩。**缓存穿透：**缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。**缓存击穿：**对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</code></pre></blockquote><h2 id="24-解释MVC和MVVM思想"><a href="#24-解释MVC和MVVM思想" class="headerlink" title="24. 解释MVC和MVVM思想"></a>24. 解释MVC和MVVM思想</h2><blockquote><pre><code>MVC Model、View、Controller　　1）最上面的一层，是直接面向最终用户的"视图层"（View）。它是提供给用户的操作界面，是程序的外壳。　　2）最底下的一层，是核心的"数据层"（Model），也就是程序需要操作的数据或信息。　　3）中间的一层，就是"控制层"（Controller），它负责根据用户从"视图层"输入的指令，选取"数据层"中的数据，然后对其进行相应的操作，产生最终结果。 　那这样Model和View就是相互独立的。View只负责页面的展示，Model只是数据的存储，那么也就达到了解耦和重用的目的。 MVVM 双向数据绑定           mvvm是一种设计思想，M表示Model，V表示视图View，VM表示数据与模型（区别MVC中，C是用于跳转至哪个页面，而VM只是将数据进行转换或者封装）：           VM是mvvm模式的核心，它是连接view、model的桥梁。有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。           在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。</code></pre></blockquote><h2 id="25-集群-分布式-微服务三者之间的区别和联系"><a href="#25-集群-分布式-微服务三者之间的区别和联系" class="headerlink" title="25. 集群/分布式/微服务三者之间的区别和联系"></a>25. 集群/分布式/微服务三者之间的区别和联系</h2><blockquote><pre><code>（1）、分布式是以缩短单个任务的执行时间来提升效率，而集群则是通过提高单位时间内执行的任务数来提升效率；但分布式需要做好事务管理（2）、集群模式是不同服务器部署同一套服务对外访问，实现服务的负载均衡；区别集群的方式是根据部署多台服务器业务是否相同，分布式中的每个阶段，都可以做集群；而集群并不一定就是分布式的；注意：集群需要做好Session共享，也就是接口要具有无状态特征，确保在不同服务器切换的过程中不会因为没有获取到Session而引起服务终止（3）、分布式与微服务的架构很相似，只是部署方式不一样而已；生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的（4）、在设计与开发中我们可以将分布式与集群的分开吗？    分布式的主要功能是将我们的系统模块化，将系统进行解耦，方便维护和开发；但并不能解决系统的并发性和高可用性问题；而集群恰好弥补了分布式的缺陷，一方面可以解决或者说改善系统的并发问题，另一方可以解决服务器如果出现宕机后，系统仍然可以正常运转；好的设计应该是分布式和集群相结合，具体实现就是业务拆分成很多子业务，然后针对每个子业务进行集群部署。</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习之分布式系统定义</title>
      <link href="/2021/02/21/dubbo-xue-xi-zhi-fen-bu-shi-xi-tong-ding-yi/"/>
      <url>/2021/02/21/dubbo-xue-xi-zhi-fen-bu-shi-xi-tong-ding-yi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解两种加密方式中私钥和公钥的概念</title>
      <link href="/2021/02/09/li-jie-liang-chong-jia-mi-fang-shi-zhong-si-yao-he-gong-yao-de-gai-nian/"/>
      <url>/2021/02/09/li-jie-liang-chong-jia-mi-fang-shi-zhong-si-yao-he-gong-yao-de-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、两种加密方式"><a href="#一、两种加密方式" class="headerlink" title="一、两种加密方式"></a>一、两种加密方式</h2><h3 id="1-对称加密-私钥加密方法："><a href="#1-对称加密-私钥加密方法：" class="headerlink" title="1.对称加密_私钥加密方法："></a>1.对称加密_私钥加密方法：</h3><p>  私钥加密算法，又称 对称加密算法，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个<br>密钥是不能公开的。常见的有<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">《DES加密算法》</a>、<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/">《AES加密算法》</a>。</p><h3 id="2-不对称加密-公钥加密方法："><a href="#2-不对称加密-公钥加密方法：" class="headerlink" title="2.不对称加密_公钥加密方法："></a>2.不对称加密_公钥加密方法：</h3><p>  公钥和私钥成对出现</p><p>公开的密钥叫公钥，只有自己知道的叫私钥</p><p>用公钥加密的数据只有对应的私钥可以解密</p><p>用私钥加密的数据只有对应的公钥可以解密</p><p>如果可以用公钥解密，则必然是对应的私钥加的密</p><p>如果可以用私钥解密，则必然是对应的公钥加的密</p><p>公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。</p><h2 id="二、实现数据的安全传输"><a href="#二、实现数据的安全传输" class="headerlink" title="二、实现数据的安全传输"></a>二、实现数据的安全传输</h2><p>要实现数据的安全传输，当然就要对数据进行加密了。</p><p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用非对称算法，过程如下：</p><p>首先 接收方 生成一对密钥，即私钥和公钥；</p><p>然后，接收方 将公钥发送给 发送方；</p><p>发送方用收到的公钥对数据加密，再发送给接收方；</p><p>接收方收到数据后，使用自己的私钥解密。</p><p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p><h3 id="三、对信息进行数字签名"><a href="#三、对信息进行数字签名" class="headerlink" title="三、对信息进行数字签名"></a>三、对信息进行数字签名</h3><p>除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常“数字签名”是用来验证发送方的身份并帮助保护数据的完整性。</p><p>例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：</p><p>保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</p><p>保证信息自签发后到收到为止未曾作过任何修改。</p><p>之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。</p><h3 id="四、公钥算法的缺点"><a href="#四、公钥算法的缺点" class="headerlink" title="四、公钥算法的缺点"></a>四、公钥算法的缺点</h3><p>现实中，公钥机制也有它的缺点，那就是效率非常低，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法：</p><p>首先，发送方使用对称算法对原始信息进行加密。</p><p>接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。</p><p>接收方 将公钥发送给 发送方。</p><p>发送方用公钥对对称算法的密钥进行加密，并发送给接收方。</p><p>接收方用私钥进行解密得到对称算法的密钥。</p><p>发送方再把已加密的原始信息发送给接收方。</p><p>接收方使用对称算法的密钥进行解密。</p><p>  注：本文转载自<a href="https://songlee24.github.io/2015/05/03/public-key-and-private-key/">理解公钥与私钥</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从今天起我要开始更新自己的博客啦</title>
      <link href="/2021/02/03/ha-ya-bu-sa-de-di-yi-pian-bo-ke/"/>
      <url>/2021/02/03/ha-ya-bu-sa-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="哈雅布撒的第一篇博客"><a href="#哈雅布撒的第一篇博客" class="headerlink" title="哈雅布撒的第一篇博客"></a>哈雅布撒的第一篇博客</h1><blockquote><p>一个初级菜鸟程序员明志！_<br>努力！奋斗！ 2021-02-03</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
