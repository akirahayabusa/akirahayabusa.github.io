<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>01分布式系统相关概念</title>
      <link href="/2021/08/25/01-fen-bu-shi-xi-tong-xiang-guan-gai-nian/"/>
      <url>/2021/08/25/01-fen-bu-shi-xi-tong-xiang-guan-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-大型互联网项目架构目标"><a href="#1-大型互联网项目架构目标" class="headerlink" title="1.大型互联网项目架构目标"></a>1.大型互联网项目架构目标</h2><p>用户体验 ：美观、功能、速度、稳定性<br>注：衡量一个网站速度是否快：1. 打开一个新页面可以一瞬间（0.36）完成；2.页面内跳转，一刹那（0.018）间完成。</p><h3 id="1-1传统项目和互联网项目"><a href="#1-1传统项目和互联网项目" class="headerlink" title="1.1传统项目和互联网项目"></a>1.1传统项目和互联网项目</h3><ul><li><p>互联网项目例如天猫、微信、百度等<br>特点：用户多；流量大，并发高；海量数据；易受攻击；功能繁琐；变更快；<br>目标：</p></li><li><p>传统项目例如OA(办公自动化系统)、HR（人事系统）、CRM（客户关系管理系统）<br>区别：传统项目用户群体员工，互联网项目网民。</p></li></ul><h3 id="1-2-大型互联网项目架构目标"><a href="#1-2-大型互联网项目架构目标" class="headerlink" title="1.2 大型互联网项目架构目标"></a>1.2 大型互联网项目架构目标</h3><ul><li><ol><li>高性能</li></ol></li></ul><p>性能指标</p><ol><li><p>响应时间：指执行一个请求从开始到最后收到响应数据花费的总体时间</p></li><li><p>并发数量：系统能处理的请求数量<br> 2.1 并发连接数：指客户端向服务器发起请求，并建立TCP连接。每秒钟服务器连接的总TCP数量；<br> 2.2 并发请求数：也称为QPS（Query Per Second）指每秒多少请求；<br> 2.3 并发用户数：单位时间内有多少用户</p></li><li><p>吞吐数量：指单位时间内系统能处理的请求数量<br> 3.1 QPS:Query Per Second 每秒查询数<br> 3.2 TPS:Transactions Per Second 每秒事务数<br> 3.3 一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。<br> 3.4 一个页面的一次访问，只会形成一个TPS，一次页面请求可能多次对服务器请求，就会有多个QPS</p><blockquote><p>QPS &gt;=并发连接数 &gt;=TPS</p></blockquote></li></ol><ul><li><ol start="2"><li>高可用：网站可以一直访问</li></ol></li><li><ol start="3"><li>可伸缩：通过硬件的增加或减少从而提高或降低处理能力</li></ol></li><li><ol start="4"><li>高可扩展：系统间耦合低，方便的新增或移除方式，增加或减少功能或模块</li></ol></li><li><ol start="5"><li>安全性</li></ol></li><li><ol start="6"><li>敏捷性：随需应变，快速响应</li></ol></li></ul><h2 id="2-集群和分布式"><a href="#2-集群和分布式" class="headerlink" title="2.集群和分布式"></a>2.集群和分布式</h2><ul><li><p>集群：很多“机器”一起，干一样的事</p></li><li><p>分布式：很多”机器“一起，干不一样的事，合起来是一件大事<br>微服务是一种特殊的分布式，粒度更小</p><p><img src="/medias/article/dubbo01/image-20210825203133390.png" alt="image-20210825203133390"></p><h2 id="3-架构演进"><a href="#3-架构演进" class="headerlink" title="3.架构演进"></a>3.架构演进</h2><p>单体架构（单机，多机）-&gt;垂直架构-&gt;分布式架构-&gt;SOA架构-&gt;微服务架构</p></li></ul><p>单体架构：</p><p>优点：</p><ul><li>简单：开发部署都很方便，小型项目首选</li></ul><p>缺点：</p><ul><li>项目启动慢</li><li>伸缩性差</li><li>可靠性差</li><li>扩展性和可维护性差</li><li>性能低</li></ul><p><img src="/medias/article/dubbo01/image-20210825204437810.png" alt="单一应用架构"></p><p>垂直架构：垂直架构是指将单体架构中的多个模块拆分为多个独立项目。形成多个独立的单体架构。 </p><p>存在问题：重复功能太多。</p><p><img src="/medias/article/dubbo01/image-20210825205108358.png" alt="垂直应用架构"></p><p><img src="/medias/article/dubbo01/image-20210825211112349.png" alt="垂直应用架构"></p><ul><li>分布式架构是指在垂直架构的基础上，将公共业务模块抽离出来，作为独立的服务，供其他调用者消费，以实现服务的共享和重用。</li><li>RPC:Remote Procedure Call 远程过程调用。有许多非常多的协议和技术来都实现了RPC的过程。比如HTTP REST风格，Java RMI规范，WebService SOAP协议、Hession等。<br>分布式架构存在问题：<br>服务提供方一旦发生变更，所有消费方都需要变动。</li></ul><p><img src="/medias/article/dubbo01/image-20210825205557602.png" alt="RPC分布式架构"></p><p><img src="/medias/article/dubbo01/image-20210825211241005.png" alt="RPC分布式架构"></p><ul><li>SOA：（Service-Oriented Architecture,面向服务的架构）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。</li><li>ESB: (Enterparise Servce Bus)企业服务总线，服务中介。主要提供了一个服务于服务之间的交互。ESB包含的功能如：负载均衡，流量控制，加密处理，服务的监控，异常处理，监控告急等等。</li></ul><p><img src="/medias/article/dubbo01/image-20210825212551650.png" alt="image-20210825212551650"></p><p>微服务架构</p><ul><li><p>微服务架构是在SOA上做的升华，微服务架构强调的一个重点是”业务需要彻底的组件化和服务化“，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。</p></li><li><p>微服务架构=80%的SOA服务架构思想+100%的组件化架构思想+80%的领域建模思想</p></li><li><p>特点：</p><ul><li>服务实现组件化：开发者可以自由选择开发技术。也不需要协调其他团队。</li><li>服务之间交互一般使用REST API</li><li>去中心化：每个微服务有自己私有的数据库持久化业务数据</li></ul></li></ul><p><img src="/medias/article/dubbo01/image-20210825220012183.png" alt="image-20210825220012183"></p><p><img src="/medias/article/dubbo01/image-20210825205757824.png" alt="流动架构"></p><p>dubbo是SOA时代的产物，springCloud 是微服务时代的产物。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01初始容器化技术docker</title>
      <link href="/2021/08/25/01-chu-shi-rong-qi-hua-ji-zhu-docker/"/>
      <url>/2021/08/25/01-chu-shi-rong-qi-hua-ji-zhu-docker/</url>
      
        <content type="html"><![CDATA[<p>我们写好的代码会接触到的环境：开发环境、测试环境以及生产环境：<br>docker可以将环境和代码装到容器里一起发布到测试环境和生产环境就解决了与开发环境水土不服的问题。</p><h2 id="1-docker概念"><a href="#1-docker概念" class="headerlink" title="1.docker概念"></a>1.docker概念</h2><ul><li>docker是一个开源的应用容器引擎，dotCloud(后改名Docker Inc)基于Go语言于2013发布。</li><li>Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上。</li><li>容器是完全沙箱机制，相互隔离。</li><li>容器性能开销极低。</li><li>docker从17.03后分为CE(Community Edition社区版和Enterprise Edition:企业版）<h2 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2.安装docker"></a>2.安装docker</h2>docker<a href="https://www.docker.com/">官网</a>，可以运行再MAC、WINDOWS、CENTOS、UBUNTU等操作系统上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02鸿蒙-HarmonyOS-应用开发入门</title>
      <link href="/2021/08/13/02-hong-meng-harmonyos-ying-yong-kai-fa-ru-men/"/>
      <url>/2021/08/13/02-hong-meng-harmonyos-ying-yong-kai-fa-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-组件"><a href="#1-组件" class="headerlink" title="1.组件"></a>1.组件</h2><p>页面所展示出来的文本框，按钮等展示的元素都是组件。</p><p>注意：组件在未被添加到布局中时，既无法显示也无法交互，因此一个用户界面至少要包含一个布局。</p><p>如：按钮组件、图片组件、文本框组件、文本输入框组件、进度条组件，音量滑块组件，单选框组件。</p><p>分类：显示类组件（图片组件，文本组件，进度条组件等）、交互类组件（按钮组件，输入框组件，多选框组件，单选框组件，滑块组件等）、布局是容器类的组件<br>父类：Component（包括布局）</p><h3 id="1-1显示类组件"><a href="#1-1显示类组件" class="headerlink" title="1.1显示类组件"></a>1.1显示类组件</h3><h4 id="1-1-1文本组件（text）"><a href="#1-1-1文本组件（text）" class="headerlink" title="1.1.1文本组件（text）"></a>1.1.1文本组件（text）</h4><ol><li><p>常见属性说明：</p><p><img src="/medias/article/harmonyos02/image-20210821220040401.png" alt="image-20210821220040401"></p><p><img src="/medias/article/harmonyos02/image-20210821220115424.png" alt="image-20210821220115424"></p></li></ol><p>特别说明属性值说明：</p><ul><li><p>宽高属性</p><ol><li><p>match_content 包裹内容</p></li><li><p>match_parent 填充父元素</p></li><li><p>或者具体数值单位</p><p>3.1 px(像素):固定的</p><p>3.2 vp（虚拟像素）：宽高<br>   vp = (px<em>160)/PPI:<br>   PPI:屏幕像素点密度（Pixels Per Inch）:对角线像素点个数/屏幕尺寸：每英寸有多少个像素点.<br>   例：假如要在布局上设置width为100px的组件，则vp=(100px</em>160)/PPI</p><p>3.3 fp   (像素)：文字大小</p></li></ol></li></ul><p><img src="/medias/article/harmonyos02/image-20210823134537061.png" alt="image-20210823134537061"></p><ul><li>颜色属性：</li></ul><ol><li>三元色：[透明度]红绿蓝</li><li>范围：0~255</li><li>表示方法：十六进制（#00917643）注：两两一样时可以省略为一个</li></ol><ul><li>位置属性</li></ul><ol><li>边距<br> 1.1 外边距(margin、top_margin、bottom_margin、left_margin、right_margin)<br> 组件边框外侧距离其他组件的距离。<br> 如果组件外侧没有其他组件，则是到父布局的距离。<br> 1.2. 内边距(padding、top_padding、botton_padding、left_padding、right_padding)<br> 组件边框的内侧和文本之间的间距。<br> 一般设置上左就行了。</li></ol><ul><li>展示大段文字</li></ul><ol><li>文字过长自动换行<br>ohos:multiple_lines=”true”(自动换行)<br>ohos:max_text_lines=”1”  (文本最大行数)</li><li>文字过长省略开头<br>ohos:truncation_mode=”ellipsis_at_start”</li><li>文字过长省略结尾<br>ohos:truncation_mode=”ellipsis_at_end”</li><li>文字过长省略中间<br>ohos:truncation_mode=”ellipsis_at_middle”</li><li>跑马灯效果<br>ohos:truncation_mode=”auto_scrolling”(文本允许自动滚动)<br>ohos:auto_scrolling_count=”unlimited”（滚动次数）<br>ohos:auto_scrolling_duration=”2000”（滚动速度）<br>text.startAutoScrolling();（开启跑马灯效果）<h4 id="1-1-2图片组件（Image）"><a href="#1-1-2图片组件（Image）" class="headerlink" title="1.1.2图片组件（Image）"></a>1.1.2图片组件（Image）</h4>属性介绍：<br>background_element(背景图片)<br>image_src(展示图片|前景图片)<br>clip_alignment(裁剪方式)<br>scale_mode(缩放模式)</li></ol><h2 id="2-布局"><a href="#2-布局" class="headerlink" title="2.布局"></a>2.布局</h2><p>多个组件摆放的方式就是布局，组件必须添加到布局中才能够显示出来。</p><h2 id="3-事件"><a href="#3-事件" class="headerlink" title="3.事件"></a>3.事件</h2><p>就是可以被组件识别的操作。<br>常见的事件：单机、双击、长按、滑动</p><h3 id="3-1单击事件"><a href="#3-1单击事件" class="headerlink" title="3.1单击事件"></a>3.1单击事件</h3><p>单击事件又叫做点击事件。是开发中使用最多的一种事件没有之一。<br>实现步骤：</p><ol><li>通过id找到组件</li><li>给按钮组件设置单击事件</li><li>写一个类实现clickedListener接口并重写onClick方法</li><li>编写onclick方法体<br>四种方式：</li></ol><ul><li>匿名内部类<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">button = (Button) this.findComponentById(ResourceTable.Id_btn1);</span><br><span class="line">//this：本类的对象。子界面对象。</span><br><span class="line">//用this调用方法，this可以省略不写</span><br><span class="line">//返回的是一个组件父类对象需要向下转型。</span><br><span class="line">// 为按钮设置点击事件回调</span><br><span class="line">        button.setClickedListener(new Component.ClickedListener() {</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(Component component) {</span><br><span class="line">                // 此处添加点击按钮后的事件处理逻辑</span><br><span class="line">                //Componet：所有组件的父类</span><br><span class="line">                button.setText("已点击");</span><br><span class="line">            }</span><br><span class="line">        });</span><br></pre></td></tr></tbody></table></figure></li><li>自定义实现类<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyListener implements Component.ClickedListener{</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(Component component) {</span><br><span class="line">        Button button= (Button) component;</span><br><span class="line">        button.setText("已点击");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>当前类做实现类</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myfirstapplication.slice;</span><br><span class="line"></span><br><span class="line">import com.example.myfirstapplication.ResourceTable;</span><br><span class="line">import com.example.myfirstapplication.SecondAbility;</span><br><span class="line">import ohos.aafwk.ability.AbilitySlice;</span><br><span class="line">import ohos.aafwk.content.Intent;</span><br><span class="line">import ohos.aafwk.content.Operation;</span><br><span class="line">import ohos.agp.components.Button;</span><br><span class="line">import ohos.agp.components.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MainAbilitySlice extends AbilitySlice implements Component.ClickedListener {</span><br><span class="line">    Button btn;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStart(Intent intent) {</span><br><span class="line">        super.onStart(intent);</span><br><span class="line">        super.setUIContent(ResourceTable.Layout_ability_main);</span><br><span class="line">        //1.找到按钮_id</span><br><span class="line">        btn= (Button) findComponentById(ResourceTable.Id_but1);</span><br><span class="line"></span><br><span class="line">        //2.给按钮添加一个点击事件,执行本类的oncLick方法</span><br><span class="line">        btn.setClickedListener(this);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActive() {</span><br><span class="line">        super.onActive();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onForeground(Intent intent) {</span><br><span class="line">        super.onForeground(intent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(Component component) {</span><br><span class="line">        //因为页面中有很多按钮，每个按钮做的事写在一个if里</span><br><span class="line">        if(component == btn){</span><br><span class="line"></span><br><span class="line">            //创建一个包含页面跳转一系列操作的意图对象</span><br><span class="line">            Intent intent=new Intent();</span><br><span class="line">            Operation operation = new Intent.OperationBuilder().withDeviceId("")//要跳转到哪个设备</span><br><span class="line">                    .withBundleName("com.example.myfirstapplication")//应用</span><br><span class="line">                    .withAbilityName(SecondAbility.class).build();//页面</span><br><span class="line"></span><br><span class="line">            //把打包之后的Operation设置到意图当中</span><br><span class="line">            intent.setOperation(operation);</span><br><span class="line">            //跳转页面</span><br><span class="line">            startAbility(intent);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>方法引用<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">button = (Button) findComponentById(ResourceTable.Id_btn1);</span><br><span class="line">        //方法引用</span><br><span class="line">        button.setClickedListener(this::onclick);</span><br><span class="line">       //注意返回值类型以及形参类型</span><br><span class="line">    public void onclick(Component component) {</span><br><span class="line">        Button button = (Button) component;</span><br><span class="line">        button.setText("已点击");</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="3-2双击事件"><a href="#3-2双击事件" class="headerlink" title="3.2双击事件"></a>3.2双击事件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setDoubleClickedListener(this::onDoubleClick);</span><br></pre></td></tr></tbody></table></figure><h3 id="3-3长按事件"><a href="#3-3长按事件" class="headerlink" title="3.3长按事件"></a>3.3长按事件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//方法引用</span><br><span class="line">button3.setClickedListener(this::onclick3);</span><br></pre></td></tr></tbody></table></figure><h3 id="3-4滑动事件"><a href="#3-4滑动事件" class="headerlink" title="3.4滑动事件"></a>3.4滑动事件</h3><p>包括三个动作：按下不松（按下位置），移动，松开（松开位置）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class FouthAbilitySlice extends AbilitySlice {</span><br><span class="line">    Text text;</span><br><span class="line">    int count;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStart(Intent intent) {</span><br><span class="line">        super.onStart(intent);</span><br><span class="line">        super.setUIContent(ResourceTable.Layout_ability_fouth);</span><br><span class="line">//        先找到布局对象</span><br><span class="line">        DirectionalLayout dl= (DirectionalLayout) findComponentById(ResourceTable.Id_dl1);</span><br><span class="line"></span><br><span class="line">        text = (Text) this.findComponentById(ResourceTable.Id_text1);</span><br><span class="line">//        添加滑动事件</span><br><span class="line">        //当我们在整个布局滑动的时候就会调用onTouchEvent方法</span><br><span class="line">        dl.setTouchEventListener(this::onTouchEvent);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean onTouchEvent(Component component, TouchEvent touchEvent) {</span><br><span class="line">        count++;</span><br><span class="line">        //参数1：component表示滑动的那个组件：布局也是组件</span><br><span class="line">        //参数2：touchEvent动作对象（按下，滑动，抬起）</span><br><span class="line">        int action=touchEvent.getAction();</span><br><span class="line">        //1 表示按下</span><br><span class="line">        //2 表示松开</span><br><span class="line">        // 3.移动滑动</span><br><span class="line">        if (action==POINT_MOVE){</span><br><span class="line">            //滑动</span><br><span class="line">            text.setText("滑动"+count);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        else if(action==PRIMARY_POINT_DOWN){</span><br><span class="line">            //按下</span><br><span class="line">            text.setText("按下"+count);</span><br><span class="line"></span><br><span class="line">        }else {</span><br><span class="line">            //松开</span><br><span class="line">            text.setText("松开"+count);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        //由此说明滑动事件是不断地调用ontouchEvent方法的</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上下左右滑动松开时滑动方式检测</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  //获取按下时手指的位置（坐标）</span><br><span class="line">MmiPoint pointerPosition = touchEvent.getPointerPosition(0);</span><br><span class="line"></span><br><span class="line">            x2 = pointerPosition.getX();</span><br><span class="line"></span><br><span class="line">            y2 = pointerPosition.getY();</span><br><span class="line">            text.setText("滑动"+count);</span><br><span class="line">            text.setText(x2+"----"+y2);</span><br><span class="line"></span><br><span class="line">                if (x2-x&gt;0 &amp;&amp; Math.abs(y2-y)&lt;=50){</span><br><span class="line">                    text.setText("右滑");</span><br><span class="line">                }</span><br><span class="line">                else if(x2-x&lt;0 &amp;&amp; Math.abs(y2-y)&lt;=50){</span><br><span class="line">                    text.setText("左滑");</span><br><span class="line">                }</span><br><span class="line">                else if (y2-y&gt;0 &amp;&amp; Math.abs(x2-x)&lt;=50){</span><br><span class="line">                    text.setText("下滑");</span><br><span class="line">                }</span><br><span class="line">                else if (y2-y&lt;0 &amp;&amp; Math.abs(x2-x)&lt;=50){</span><br><span class="line">                    text.setText("上滑");</span><br><span class="line">                }</span><br><span class="line">                else{</span><br><span class="line">                    text.setText("没动");</span><br><span class="line">                }</span><br><span class="line">            </span><br></pre></td></tr></tbody></table></figure><p> public boolean onTouchEvent(Component component, TouchEvent touchEvent)<br> 如果返回值为true，表示所有的动作都会触发当前方法并且执行对应的代码。<br> 如果返回值为false，表示只有第一个动作会出发当前方法并执行对应代码。后续的动作就不会触发当前方法了。(按下–移动-松开只有按下时会触发一次。)</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸿蒙 </tag>
            
            <tag> HarmonyOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>忍者龙剑传1（西格玛，黑之章）应对策略</title>
      <link href="/2021/08/13/ren-zhe-long-jian-chuan-1-xi-ge-ma-hei-zhi-zhang-ying-dui-ce-lue/"/>
      <url>/2021/08/13/ren-zhe-long-jian-chuan-1-xi-ge-ma-hei-zhi-zhang-ying-dui-ce-lue/</url>
      
        <content type="html"><![CDATA[<p>该篇主要帮助一些卡关忍龙1代（黑之章和西格玛）超忍流程的一些应对策略。</p><h2 id="1-实用操作"><a href="#1-实用操作" class="headerlink" title="1.实用操作"></a>1.实用操作</h2><ul><li>处决：一代敌人，倒地后，在其身边按y可处决。</li><li>跳墙斩：在忍龙一代中跳墙斩绝对算的上是神技，施展过程中伴随着大量的无敌时间。</li><li>踩头：伴随着踩头会同样会有无敌帧可以有效躲避来自忍者的爆标，同时可以踩头后反向y操作可以将敌人打倒在地，之后y处决。</li><li>断头摔：断头摔后紧接着飞燕可以爆头率很高哦。</li><li>手里剑：别看手里剑的伤害并不高，其正确的用途往往是用来牵制敌人，战斗中灵活运用，可以简化很多战斗。</li><li>防反</li></ul><h2 id="2-boss战"><a href="#2-boss战" class="headerlink" title="2.boss战"></a>2.boss战</h2><ul><li>第一章村井：黑之章中可以xy挑空，如果第二下y打中则落地按y接一文字。由于西格玛ai有变没魂时落地一文字必被投，所以xyy比较稳妥。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 忍者龙剑传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01鸿蒙(HarmonyOS)应用开发入门</title>
      <link href="/2021/08/07/01-hong-meng-harmonyos-ying-yong-kai-fa-ru-men/"/>
      <url>/2021/08/07/01-hong-meng-harmonyos-ying-yong-kai-fa-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-鸿蒙系统介绍"><a href="#1-鸿蒙系统介绍" class="headerlink" title="1.鸿蒙系统介绍"></a>1.鸿蒙系统介绍</h2><h3 id="1-1官方定义"><a href="#1-1官方定义" class="headerlink" title="1.1官方定义"></a>1.1官方定义</h3><ul><li><p>鸿蒙是一个全场景，面向未来的操作系统。</p></li><li><p>解释：</p></li></ul><p>鸿蒙并不是一个单纯的手机操作系统，而是手机 + 智能设备的总称。可以安装在包括手机、手表、无人机等很多</p><ul><li>设备上鸿蒙分为两类：</li></ul><ol><li>应用开发：也是整个鸿蒙的控制中心。（手机app）</li></ol><p>开发语言：Java，js，C/C++（华为目前建议使用的还是Java）</p><p>内核：基于Linux内核开发的。</p><ol start="2"><li>设备开发：也就是无人机，摄像机等硬件设备。</li></ol><p>最合适的开发语言：C/C++</p><p>内核：基于LiteOS内核开发的。</p><p>于LiteOS的特点：轻量级（内核小于10k）、低功耗（1节5号电池最多可以工作5年）。</p><p>鸿蒙系统可以覆盖所有的设备，应用在智能设备上，比如摄像头、门铃、体温计等设备。</p><p>利用软总线将各个设备连接起来。</p><h4 id="1-1-1-官方网址："><a href="#1-1-1-官方网址：" class="headerlink" title="1.1.1 官方网址："></a>1.1.1 官方网址：</h4><p><a href="https://www.harmonyos.com/">https://www.harmonyos.com</a></p><h4 id="1-1-2-鸿蒙的特点："><a href="#1-1-2-鸿蒙的特点：" class="headerlink" title="1.1.2 鸿蒙的特点："></a>1.1.2 鸿蒙的特点：</h4><ul><li>one as all，all as one</li></ul><p>HarmonyOS是新一代的智能终端操作系统，为不同设备的智能化、互联与协同提供了统一的语言。带来简洁、流畅、连续、安全可靠的全场景交互体验。</p><ul><li>统一OS，弹性部署</li></ul><p>一套操作系统，满足大大小小所有设备的需求，小到耳机，大到车机，智慧屏，手机等，让不同设备使用同一语言无缝沟通。</p><ul><li>硬件互助，资源共享</li></ul><p>搭载HarmonyOS 的每个设备都不是孤立的，在系统层让多终端融为一体，成为“超级终端”，终端之间能力互助共享，带来无缝协同体验。</p><ul><li>一次开发，多端部署</li></ul><p>开发者基于分布式应用框架，写一次逻辑代码，就可以部署在多种终端上。</p><ul><li>应用自由跨端</li></ul><p>HarmonyOS原子化服务是轻量化服务的新物种，它提供了全新的服务和交互方式，可分可合，可流转，支持免安装等特性，能够让应用化繁为简，让服务触手可及。</p><ul><li>用“简单”激活你的设备智能</li></ul><p>HarmonyOS是新一代智能终端操作系统。为不同设备的智能化、互联与协同提供了统一的语言。设备可实现一碰入网，无屏变有屏，操作可视化，一键直达原厂服务等全新功能。通过简单而智能的服务，实现设备智能化产业升级。</p><h3 id="1-2-鸿蒙和安卓的对比"><a href="#1-2-鸿蒙和安卓的对比" class="headerlink" title="1.2 鸿蒙和安卓的对比"></a>1.2 鸿蒙和安卓的对比</h3><ul><li>内核方面的对比</li></ul><p>安卓系统是基于linux的宏内核设计 ，宏内核包含了操作系统绝大多数的功能和模块，而且这些功能和模块都具有最高的权限，只要一个模块出错，整个系统就会崩溃，这也是安卓系统容易崩溃的原因。好处就是系统开发难度低。<br>鸿蒙操作系统是微内核设计：微内核仅包括了操作系统必要的功能模块（任务管理、内存分配等）处在核心地位具有最高权限，其他模块不具有最高权限，也就是说其他模块出现问题，对于整个系统的运行是没有阻碍的。微内核稳定性很高。<br>而且鸿蒙系统包含了两个内核，如果是手机app是基于Linux内核，而如果是其他的硬件是基于LiteOS内核。</p><ul><li>运行速度的对比<br>安卓程序不能与系统底层直接进行通信活动，是运行在虚拟机上的。如果虚拟机出了问题话的那系统就是卡住。<br>鸿蒙系统中的方舟编译器解决了这个问题的，任何由编译器编译的软件，是直接运行在操作系统中的，可以直接与系统底层进行通信。</li><li>作为手机操作系统的对比<br>安卓和鸿蒙都是基于安卓开源项目（AOSP）进行开发的。<br>而安卓开源平台是可以在开源许可下自由使用和修改的。国内外很多手机厂商都根据这套代码制定了自己的操作系统，比如：三星、小米、魅族等。而华为也是基于这套开源体系，制定了鸿蒙操作系统。<br>鸿蒙操作系统的构成：</li></ul><blockquote><p>HarmonyOS = 安卓开放平台的开源代码 - GMS - 安卓UI + HMS + 鸿蒙UI + 分布式软总线 + 以Ability为核心的应用开发框架。</p></blockquote><ul><li>连接其他设备的对比</li></ul><p>安卓手机连接其他设备，不管从app开发方面，还有使用方面都非常麻烦，而且如果换一个第三方设备，还需要把发现，配对，连接，组合，验证的过程再次操作一遍。</p><p>但是鸿蒙就非常简单了，从app开发方面，只要写很少的代码就可以调用第三方硬件，从使用的角度来讲，不管是多少设备连在一起，鸿蒙的终极目标是都能像使用一台设备那样简单。</p><h3 id="1-3-鸿蒙会取代安卓吗？"><a href="#1-3-鸿蒙会取代安卓吗？" class="headerlink" title="1.3 鸿蒙会取代安卓吗？"></a>1.3 鸿蒙会取代安卓吗？</h3><p>如果有的同学有这样的想法，那么格局太小了。针对于IT行业，一般来讲头部力量或者已经形成生态的东西，很难撼动他的地位。鸿蒙的出现并不是为了取代安卓，而是把眼光放在下下一个时代，也就是5G时代。在5G时代中，最重要的是万物互联的时代。华为是想要在5G时代占据主导权。</p><h3 id="1-4几张图说明鸿蒙"><a href="#1-4几张图说明鸿蒙" class="headerlink" title="1.4几张图说明鸿蒙"></a>1.4几张图说明鸿蒙</h3><p><img src="/medias/article/harmonyos/image-20210808110213386.png" alt="image-20210808110213386"></p><p><img src="/medias/article/harmonyos/image-20210808110236988.png" alt="image-20210808110236988"></p><p><img src="/medias/article/harmonyos/image-20210808110259436.png" alt="image-20210808110259436"></p><p><img src="/medias/article/harmonyos/image-20210808110315222.png" alt="image-20210808110315222"></p><h3 id="1-5-为什么要学习鸿蒙开发？"><a href="#1-5-为什么要学习鸿蒙开发？" class="headerlink" title="1.5 为什么要学习鸿蒙开发？"></a>1.5 为什么要学习鸿蒙开发？</h3><h4 id="开发者的角度："><a href="#开发者的角度：" class="headerlink" title="开发者的角度："></a>开发者的角度：</h4><p>安卓操作系统连接外部设备时，发现，配对，连接，组合，验证每一步都不能少。连接上了之后才能调用控制第三方设备。换一个设备之后，所有的代码需要重写。所有用安卓也可以连接外部设备并进行控制，但是太过于麻烦。而且不具备通用性。</p><p>鸿蒙操作系统就解决了这个痛点，设备与设备之间的连接就不需要我们开发者自己去写了，每一个设备都安装上鸿蒙操作系统之后，鸿蒙系统会通过软总线把这些设备都连接在一起。我们在应用开发的时候，只需要写很少的代码就可以调用第三方设备，就好像是使用手机本身的设备一样方便。</p><p>所以，在鸿蒙的整个体系中，手机不仅仅是手机了，而是一个超控控制终端。这个终端可能会有十个屏幕，十个喇叭等。调用手机本身的硬件跟调用外部的硬件几乎没有任何差别。</p><h4 id="使用者的角度："><a href="#使用者的角度：" class="headerlink" title="使用者的角度："></a>使用者的角度：</h4><p>安卓操作系统中，所有的操作都是在手机上的，比如我们在导航的时候，都是用手机进行导航。但是在有的时候，我们是不方便拿着手机导航的，比如下雨天一个手撑伞一个手拎东西。</p><p>而在鸿蒙操作系统中，我们就可以把手机导航直接迁移到鸿蒙手表中就可以了。用户使用起来非常方便。</p><p>比如：我在A手机上编辑一封邮件的时候，需要添加一个excel附件。但是这个附件不在A手机上面，而是在B手机上面。传统做法要么就是从B手机上发过来，要么就是电脑复制文件，再粘贴过来，挺麻烦的。但是如果使用鸿蒙系统就方便了。我们可以直接数据迁移，把A手机里面编辑的邮件，迁移到B手机上。或者通过鸿蒙系统连上B手机之后直接使用B手机里面的附件。</p><p>除此之外，如果利用安卓操作系统控制硬件还需要下载很多的app，每一个app都有好几十兆，甚至上百兆。比如我要控制美的的冰箱，就需要下载一个app，要控制微波炉，又要下载一个app，如果我家里有100个电器，那么就要下载100个app，太麻烦了。在我们生活中，最烦的事情就是在手机中下载各种各样的app。而且下载完了之后，还需要扫描硬件，发现硬件，连接硬件，最后才能控制。</p><p>鸿蒙就为用户解决了这个问题，如果我们要控制冰箱，我们只要利用鸿蒙手机碰一下冰箱对应的芯片，那么鸿蒙手机就会到自己的应用中心，把控制冰箱的模块下载到手机里面然后直接打开控制中心，中间花费时间大约3秒左右，用户根本感觉不到下载和安装的过程。同理，如果我们要控制微波炉，也只要用手机碰一下微波炉对应的芯片，那么鸿蒙手机就会到自己的应用中心，把控制微波炉的模块下载到手机里面然后直接打开控制中心，对于用户来讲，非常的方便。所以鸿蒙一旦在市场铺开之后，用户用起来会非常的爽。</p><h2 id="2-鸿蒙系统环境搭建"><a href="#2-鸿蒙系统环境搭建" class="headerlink" title="2.鸿蒙系统环境搭建"></a>2.鸿蒙系统环境搭建</h2><h3 id="2-1开发流程"><a href="#2-1开发流程" class="headerlink" title="2.1开发流程"></a>2.1开发流程</h3><p>注册证号-&gt;实名认证-&gt;安装软件-&gt;编写代码-&gt;测试代码-&gt;发布应用<br><img src="/medias/article/harmonyos/image-20210808132621623.png" alt="image-20210808132621623"></p><h3 id="2-2-注册账号并实名认证"><a href="#2-2-注册账号并实名认证" class="headerlink" title="2.2 注册账号并实名认证"></a>2.2 注册账号并实名认证</h3><p><a href="http://www.harmonyos.com/">鸿蒙官网</a></p><h3 id="2-3鸿蒙开发的语言"><a href="#2-3鸿蒙开发的语言" class="headerlink" title="2.3鸿蒙开发的语言"></a>2.3鸿蒙开发的语言</h3><ol><li>java（应用主流）</li><li>js</li><li>c/c++ （硬件主流）</li><li>仓颉<h3 id="2-4开发工具"><a href="#2-4开发工具" class="headerlink" title="2.4开发工具"></a>2.4开发工具</h3></li></ol><ul><li>工具名称：DevEco Studio</li><li>版本说明：<br>DevEco Studio 1.0 用于华为EMUI系统的应用App。<br>DevEco Studio 2.0 用于华为鸿蒙系统的应用App。</li><li>使用Java开发:<br>开发工具会帮我们自动下载JDK、展示界面以及开发工具等相关软件。所以我们不需要自己安装JDK等环境。</li><li>JDK和工具链<br>JDK： 是Java语言所需要的开发环境。鸿蒙开发工具DevEco Studio会帮我们自动下载。鸿蒙开发工具目前只支持JDK8。<br>工具链：就是开发软件DevEco Studio里面需要用到的一些插件工具。</li></ul><ol><li>Toolchains：SDK工具链，HarmonyOS应用开发必备工具集，包括编译、打包、签名、数据库管理等工具的集合，首次下载SDK时默认下载。</li><li>Previewer：Lite Wearable预览器，在开发过程中可以动态预览Lite Wearable应用的界面呈现效果，默认不自动下载，需手动勾选下载。</li></ol><ul><li>安装开发工具IDE</li></ul><ol><li>安装IDE时候的坑1：一直加载gradle</li><li><ol><li>下载指定的gradle版本<br>可以到 官网下载或者借助网友提供的下载好的版本，直接下载使用。</li></ol></li><li><ol start="2"><li>打开DevEco studio自动加载路径<br>默认在这个目录：C:\Users\Administrator.gradle\wrapper\dists\gradle-6.3-all\b4awcolw9l59x95tu1obfh9i8</li></ol></li><li><ol start="3"><li>下载好的zip文件放进去<br>将下载好的gradle文件复制在以上文件夹内(注意一定要放置在类似“3221gyojl5jsh0helicew6rwx”目录下)，重启软件即可。</li></ol></li><li><ol start="4"><li>修改模板<br>首先进入/plugins/harmony目录，这是DevEco Studio的插件目录。在该目录下继续找到<br>lib/templates/gradle/wrapper/gradle/wrapper/gradle-wrapper.properties文件，该文件就是每次创建HarmonyOS工程时的gradle-wrapper.properties文件，打开该文件，将distributionUrl改成<a href="http://127.0.0.1/gradle-6.3-all.zip">http://127.0.0.1/gradle-6.3-all.zip</a> 即可。然后重新启动DevEco Studio。</li></ol></li><li>安装IDE时候的坑2：模拟器刷不出来<br>开发应用的时候需要模拟器跑效果，需要在DevEco Studio菜单栏，点击Tools &gt; HVD Manager开发模拟器，第一次打开，会自动下载相关资料。<br>注意1：浏览器一定要更新到最新版本，否则可能模拟器刷不出来。<br>目前亲测可用的浏览器有：chrom（谷歌）、火狐浏览器、360急速浏览器、360安全浏览器。<br>注意2：模拟器不是本地的，而是远程的，需要先登录才可以使用，登录的账号就是我们刚刚注册并实名认证的开发者账号。<br>注意3：模拟器启动之后只能用一小时，时间到了之后，关闭模拟器重新开启即可。</li></ol><ul><li>常见设置：</li></ul><ol><li>修改主题（setting-&gt;Appearance-&gt;Theme）</li><li>修改字体（setting-&gt;font）</li><li>修改注释字体（setting-&gt;Editor-&gt;color Scheme-&gt;Language Defaults-&gt;comments）</li><li>提示无关乎大小写（setting-&gt;Editor-&gt;General-&gt;Code Completion-&gt;去掉Match case）</li><li>自动导包(setting-&gt;Editor-&gt;General-&gt;auto import-&gt;勾选add un..以及optimize)</li><li>修改快捷键（setting-&gt;keyMap-&gt;code completion-&gt;Basic(提示)改成alt+/）</li></ol><h2 id="3-DevEco-Studio项目结构"><a href="#3-DevEco-Studio项目结构" class="headerlink" title="3.DevEco Studio项目结构"></a>3.DevEco Studio项目结构</h2><h3 id="3-1最外面的结构："><a href="#3-1最外面的结构：" class="headerlink" title="3.1最外面的结构："></a>3.1最外面的结构：</h3><p>MyApplication：整个项目的项目名</p><p>External Libraries：项目中要导入的第三方jar包</p><h3 id="3-2MyApplication的结构："><a href="#3-2MyApplication的结构：" class="headerlink" title="3.2MyApplication的结构："></a>3.2MyApplication的结构：</h3><p>展开MyApplication之后，发现很多目录，但是不是所有目录在开发中都需要经常用到的。</p><ul><li><p>.gradle：是项目管理工具gradle的信息（一般是不会动）</p></li><li><p>.idea：是开发工具的信息（一般不会动）</p></li><li><p>entry：是应用主模块，在一个项目中，有且只有一个，所有的代码都在这个里面。（重要）</p></li><li><p>gradle：项目管理工具gradle的配置信息和所需要用到的jar包，在这个里面有一个properties的配置文件，可以看到gradle的版本号，一般我们会用默认的，也不会动</p></li><li><p>build.gradle：第三方jar包的配置文件，以后在开发中要用到第三方jar包需要在这个里面配置。</p></li><li><p>gradlew：是gradle命令工具对应的脚本文件，一般不用。一个是linux系统的，一个是windows系统的。</p></li><li><p>local.properties：本地SDK配置信息，一般也不动。</p></li></ul><h3 id="3-3entry的结构："><a href="#3-3entry的结构：" class="headerlink" title="3.3entry的结构："></a>3.3entry的结构：</h3><ul><li><p>build：一般不会动，这个文件夹里面有一个R文件，记录每一个资源文件对应的id。里面的内容是自动生成的。</p></li><li><p>R文件是一个压缩包，里面装的ResourceTable这个类的字节码文件。</p></li><li><p>libs：第三方jar包存放的位置</p></li><li><p>src：主要代码</p></li></ul><h3 id="3-4src里面还有三个目录"><a href="#3-4src里面还有三个目录" class="headerlink" title="3.4src里面还有三个目录"></a>3.4src里面还有三个目录</h3><ul><li><p>main：是我们自己写的主要代码。</p></li><li><p>ohosTest：华为的测试工具。</p></li><li><p>test：是Junit的测试工具。</p></li></ul><h3 id="3-5main里面的结构目录："><a href="#3-5main里面的结构目录：" class="headerlink" title="3.5main里面的结构目录："></a>3.5main里面的结构目录：</h3><p>我们自己写的代码就在main里面。<br>main里面主要分为三个部分：</p><ul><li>java：里面是我们写的所有代码。</li><li>resources：里面是我们跟界面相关的资源文件。</li><li>config.json：是界面相关所有配置信息，每一个界面都需要在这个里面进行配置。<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3></li></ul><ol><li>在MyApplication中，我们暂时只要关心entry，这个里面是项目相关所有的资源文件和代码都在里面。</li><li>在entry中，主要知道libs和src即可。</li><li>libs中存放第三方jar包 4. src中放主要代码</li><li>在src中的main是我们主要写的代码</li><li>ohosTest是华为的测试代码</li><li>test是Junit测试代码</li><li>src中的main是我们写的所有代码</li><li>src中的resources是我们写的所有界面的布局文件</li><li>config.json里面配置了所有界面相关的信息</li></ol><h2 id="4-第一个入门应用Hello-World"><a href="#4-第一个入门应用Hello-World" class="headerlink" title="4.第一个入门应用Hello World"></a>4.第一个入门应用Hello World</h2><p>当新建完毕一个鸿蒙项目之后，自带有HelloWorld的代码。<br>所以，我们真正学习的是下面的四个知识点：</p><ul><li>如何运行项目</li><li>页面中的包含关系</li><li>配置文件：config.json</li><li>了解程序的启动流程<h3 id="4-1-如何运行项目"><a href="#4-1-如何运行项目" class="headerlink" title="4.1 如何运行项目"></a>4.1 如何运行项目</h3></li><li>登录账号</li><li>选择并开启模拟器</li><li>运行项目<br>分步操作：</li></ul><ol><li>点击Tools下面的Device Manager 或者 项目右上角的用户头像即可登录。</li><li>选择Phone里面的P40，点击右侧的绿色三角启动模拟器</li><li>点击studio上方的绿色三角即可启动项目。<h3 id="4-2页面中的包含关系"><a href="#4-2页面中的包含关系" class="headerlink" title="4.2页面中的包含关系"></a>4.2页面中的包含关系</h3>MainAbility是项目启动的第一个界面。<br>在界面里面不是直接显示内容的。在界面里面展示的是子界面，我们也称之为切片，或者片段。<br>在子界面里面才是显示内容的。<br>而展示的HelloWord是一段文本，这个文本就是放在MainAbilitySlice里面进行展示的。<br>关系如下：<blockquote><p>MainAbility （界面）包含一个或多个MainAbilitySlice（子界面）<br>MainAbilitySlice（子界面）包含要显示的内容</p></blockquote></li></ol><p>图解如下：</p><p><img src="/medias/article/harmonyos/image-20210808165312093.png" alt="image-20210808165312093"></p><h3 id="4-3-配置文件：config-json"><a href="#4-3-配置文件：config-json" class="headerlink" title="4.3 配置文件：config.json"></a>4.3 配置文件：config.json</h3><p>所有的模块，界面等信息，都会在这个文件中进行配置。<br>鸿蒙应用启动之后，先解析config.json文件。<br>config.json：分为三个部分：（app 、deviceConfig 、module）</p><ul><li>app是整个项目的配置，包含了厂商信息、版本号等。</li><li>deviceConfig：表示应用在设备上的配置信息。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：是否允许应用使用网络流量、是否支持在设备未解锁状态直接启动等</span><br></pre></td></tr></tbody></table></figure></li><li>module：表示整个代码的配置信息。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：程序在运行时候的所有界面，以及第一个要启动的界面是谁。</span><br></pre></td></tr></tbody></table></figure><h4 id="4-3-1app："><a href="#4-3-1app：" class="headerlink" title="4.3.1app："></a>4.3.1app：</h4>整个项目的配置信息<br>内容详解：</li></ul><ol><li>bundleName包名</li><li>vendor，是应用开发厂商的描述，也就是开发公司的名字。</li><li>version：<br>包含：name、code。</li></ol><h4 id="4-3-2deviceConfig："><a href="#4-3-2deviceConfig：" class="headerlink" title="4.3.2deviceConfig："></a>4.3.2deviceConfig：</h4><p>应用在设备上的配置信息 比如，应用需要获取手机里面的一些权限，就可以写在deviceConfig里面。如果不需要任何权限就可以空着不写。</p><h4 id="4-3-3module："><a href="#4-3-3module：" class="headerlink" title="4.3.3module："></a>4.3.3module：</h4><p>代码中的配置信息<br>内容详解：</p><ol><li>package 包名</li><li>name是hap包的名字</li><li>mainAbility表示HAP包的入口ability名称</li><li>deviceType表示项目可以在哪些设备上运行。<br>因为可能有多个设备，所以有个方括号，表示这些值可以写到一个数组中。 phone：手机</li><li>distro表示HAP包的描述信息</li><li>deliveryWithInstall 当前hap包是否可以支持随应用安装。一般都写成true。</li><li>moduleName：当前HAP的名称</li><li>moduleType：表示当前HAP的类型。entry也表示当前的hap是一个主要的模块，可以单独安装并运行</li><li>abilities：代码中每一个页面的配置信息。<br>关于页面ability的配置，后面我们会详细讲解。<h3 id="4-4程序的启动过程"><a href="#4-4程序的启动过程" class="headerlink" title="4.4程序的启动过程"></a>4.4程序的启动过程</h3>当程序刚开始启动的时候，会解析config.json中的信息，获取到第一个要加载的界面，也就是mainAbility，通过包名 + 类名定位到要运行的类MainAbility，所以界面启动，在这个界面里面又加载了MainAbilitySlice切片，在改切片中展示的内容为Layout包中的ability_main。</li></ol><p><img src="/medias/article/harmonyos/image-20210808170111670.png" alt="image-20210808170111670"></p><h2 id="5-第二个鸿蒙入门应用-页面跳转"><a href="#5-第二个鸿蒙入门应用-页面跳转" class="headerlink" title="5.第二个鸿蒙入门应用-页面跳转"></a>5.第二个鸿蒙入门应用-页面跳转</h2><p>这种方式也是鸿蒙官方推荐的一个入门应用。<br>最终效果</p><p><img src="/medias/article/harmonyos/image-20210809173905431.png" alt="image-20210809173905431"></p><p>设计思路：<br>第一步：在第一个界面中把HelloWorld改写为第一个界面，并添加一个按钮。<br>第二步：写第二个界面<br>第三步：书写跳转关系</p><h2 id="5-1界面布局"><a href="#5-1界面布局" class="headerlink" title="5.1界面布局"></a>5.1界面布局</h2><p>鸿蒙UI中，提供了两种编写布局的方式：</p><ul><li><p>在XML中声明UI布局</p></li><li><p>在代码中创建布局</p></li></ul><p>这两种方式创建出的布局没有本质差别，但是XML方式较为方便简单，以后开发中，也都是用XML布局的方式。</p><p>但是这两种方式都需要我们熟悉。所以，所以我们将通过XML的方式布局第一张页面，然后再通过代码的方式布局</p><p>第二张页面。</p><h3 id="5-1-1-XML文件方式配置界面"><a href="#5-1-1-XML文件方式配置界面" class="headerlink" title="5.1.1 XML文件方式配置界面"></a>5.1.1 XML文件方式配置界面</h3><ol><li>打开layout下面的“ability_main.xml”文件</li><li>在“ability_main.xml”文件中创建一个文本Text和一个按钮Button<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt; </span><br><span class="line">&lt;DependentLayout </span><br><span class="line">xmlns:ohos="http://schemas.huawei.com/res/ohos" </span><br><span class="line">ohos:width="match_parent" </span><br><span class="line">ohos:height="match_parent" </span><br><span class="line">ohos:background_element="#000000"&gt;</span><br><span class="line"></span><br><span class="line">&lt;Text </span><br><span class="line">ohos:id="$+id:text" </span><br><span class="line">ohos:width="match_content" ohos:height="match_content" ohos:text="Hello World"</span><br><span class="line">ohos:text_color="white" </span><br><span class="line">ohos:text_size="32fp" </span><br><span class="line">ohos:center_in_parent="true"/&gt; </span><br><span class="line">&lt;Button ohos:id="$+id:button" </span><br><span class="line">ohos:width="match_content" </span><br><span class="line">ohos:height="match_content" </span><br><span class="line">ohos:text="Next" </span><br><span class="line">ohos:text_size="19fp" </span><br><span class="line">ohos:text_color="white" </span><br><span class="line">ohos:top_padding="8vp" </span><br><span class="line">ohos:bottom_padding="8vp" </span><br><span class="line">ohos:right_padding="80vp" </span><br><span class="line">ohos:left_padding="80vp" ohos:background_element="$graphic:background_button" ohos:below="$id:text" </span><br><span class="line">ohos:horizontal_center="true" /&gt; </span><br><span class="line">&lt;/DependentLayout&gt;</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="5-1-2-代码方式配置界面"><a href="#5-1-2-代码方式配置界面" class="headerlink" title="5.1.2 代码方式配置界面"></a>5.1.2 代码方式配置界面</h3><ol><li>创建Feature Ability</li><li>代码编写界面<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class SecondAbilitySlice extends AbilitySlice { </span><br><span class="line">@Override</span><br><span class="line">public void onStart(Intent intent) { </span><br><span class="line">super.onStart(intent); </span><br><span class="line">// 声明布局 </span><br><span class="line">DependentLayout myLayout = new DependentLayout(this); </span><br><span class="line">// 设置页面布局大小和背景色</span><br><span class="line">myLayout.setWidth(MATCH_PARENT); </span><br><span class="line">myLayout.setHeight(MATCH_PARENT); </span><br><span class="line">ShapeElement element = new ShapeElement(); </span><br><span class="line">element.setRgbColor(new RgbColor(255, 255, 255)); </span><br><span class="line">myLayout.setBackground(element); </span><br><span class="line">// 创建一个文本 </span><br><span class="line">Text text = new Text(this); </span><br><span class="line">text.setText("Nice to meet you."); </span><br><span class="line">text.setTextSize(55); </span><br><span class="line">text.setTextColor(Color.BLACK); </span><br><span class="line">// 设置文本的布局 </span><br><span class="line">DependentLayout.LayoutConfig textConfig = new DependentLayout.LayoutConfig(MATCH_CONTENT,MATCH_CONTENT); </span><br><span class="line">textConfig.addRule(DependentLayout.LayoutConfig.CENTER_IN_PARENT);</span><br><span class="line"></span><br><span class="line">text.setLayoutConfig(textConfig); </span><br><span class="line">myLayout.addComponent(text); </span><br><span class="line">super.setUIContent(myLayout); </span><br><span class="line">}</span><br><span class="line">@Override</span><br><span class="line">public void onActive() { </span><br><span class="line">super.onActive(); </span><br><span class="line">}</span><br><span class="line">@Override</span><br><span class="line">public void onForeground(Intent intent) { </span><br><span class="line">super.onForeground(intent); </span><br><span class="line">} }</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-代码实现页面跳转"><a href="#5-2-代码实现页面跳转" class="headerlink" title="5.2 代码实现页面跳转"></a>5.2 代码实现页面跳转</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MainAbilitySlice extends AbilitySlice implements Component.ClickedListener { Button button; </span><br><span class="line">@Override</span><br><span class="line">public void onStart(Intent intent) { </span><br><span class="line">super.onStart(intent); </span><br><span class="line">super.setUIContent(ResourceTable.Layout_ability_main);</span><br><span class="line">button = (Button) findComponentById(ResourceTable.Id_text_button);</span><br><span class="line">button.setClickedListener(this); </span><br><span class="line">}</span><br><span class="line">@Override</span><br><span class="line">public void onActive() {</span><br><span class="line">super.onActive(); </span><br><span class="line">}</span><br><span class="line">@Override</span><br><span class="line">public void onForeground(Intent intent) { super.onForeground(intent);</span><br><span class="line">}</span><br><span class="line">@Override</span><br><span class="line">public void onClick(Component component) {</span><br><span class="line">if(component == button){</span><br><span class="line">//跳转页面 </span><br><span class="line">//创建一个意图对象。</span><br><span class="line">Intent i = new Intent(); </span><br><span class="line">//创建意图的参数对象。</span><br><span class="line">Operation operation = new Intent.OperationBuilder() .withDeviceId("")//本机 .withBundleName("com.example.myapplication")//哪个应用 .withAbilityName("com.example.myapplication.Second_Ability")//哪个界面</span><br><span class="line">.build(); </span><br><span class="line">i.setOperation(operation);</span><br><span class="line">startAbility(i); </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸿蒙 </tag>
            
            <tag> HarmonyOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸿蒙(HarmonyOS)应用开发路线</title>
      <link href="/2021/08/07/00-hong-meng-harmonyos-ying-yong-kai-fa-lu-xian/"/>
      <url>/2021/08/07/00-hong-meng-harmonyos-ying-yong-kai-fa-lu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-鸿蒙应用开发"><a href="#1-鸿蒙应用开发" class="headerlink" title="1.鸿蒙应用开发"></a>1.鸿蒙应用开发</h2><p>###入门路线</p><blockquote><ol><li>搭建环境</li><li>入门案例</li><li>启动流程</li><li>常见布局</li><li>常见组件</li><li>常见事件</li><li>组件高级</li><li>Ability</li><li>AbilitySlice</li><li>页面生命周期</li><li>9种页面跳转</li><li>无界面的Ability</li><li>HiLog</li><li>实战案例</li></ol></blockquote><h3 id="进阶路线"><a href="#进阶路线" class="headerlink" title="进阶路线"></a>进阶路线</h3><blockquote><ol><li>多线程</li><li>数据安全</li><li>网络</li><li>http协议</li><li>json</li><li>服务器交互</li><li>摄像头</li><li>视频采集</li><li>视频处理</li><li>录音器</li><li>声音采集</li><li>声音处理</li><li>跨设备的调用</li><li>数据库sqlite</li><li>实战案例</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸿蒙 </tag>
            
            <tag> HarmonyOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs之Express框架</title>
      <link href="/2021/08/05/nodejs-zhi-express-kuang-jia/"/>
      <url>/2021/08/05/nodejs-zhi-express-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Express简介"><a href="#一、Express简介" class="headerlink" title="一、Express简介"></a>一、Express简介</h2><ul><li><p>是什么：基于nodejs开发的一个框架</p></li><li><p>好  处：加快项目开发，便于团队协作</p></li></ul><h2 id="二、使用（初体验）"><a href="#二、使用（初体验）" class="headerlink" title="二、使用（初体验）"></a>二、使用（初体验）</h2><ul><li><p>步骤1：创建day24_express开发目录</p></li><li><p>步骤2：安装express框架</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">npm install express</span><br></pre></td></tr></tbody></table></figure><p><img src="/medias/article/nodejs02/wps1.jpg" alt="img"> </p></li><li><p>步骤3：使用</p></li></ul><p><img src="/medias/article/nodejs02/wps2.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express框架模块</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">//2.创建框架核心app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//3.路由</span><br><span class="line"></span><br><span class="line">app.get('/',  function(req, res) {</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​//Express响应数据方法</span><br><span class="line"></span><br><span class="line">​//end   - 响应字符串</span><br><span class="line"></span><br><span class="line">​//send  - 响应字符串（自动识别数据类型）</span><br><span class="line"></span><br><span class="line">​//render - 响应字符串（可以获取指定文件字符串并响应，缺点：得自己声明模板引擎）</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">​//res.end("哥哥来抓我呀，&lt;a href='http://nn.com'&gt;点击进入我的世界&lt;/a&gt;")</span><br><span class="line"></span><br><span class="line">​res.send("哥哥来抓我呀，&lt;a href='http://nn.com'&gt;点击进入我的世界&lt;/a&gt;")</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//4.启动服务</span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('Running...')</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="三、使用（配置模板引擎）"><a href="#三、使用（配置模板引擎）" class="headerlink" title="三、使用（配置模板引擎）"></a>三、使用（配置模板引擎）</h2><ul><li><p>说 明：默认通过公end或send渲染，无法加载视图，所以得自己配置默认模板引擎官方以前推荐用jade现在升级为pug也有用ejs个人推荐art模板引擎。</p></li><li><p>文 档：<a href="http://aui.github.io/art-template/zh-cn/express/">http://aui.github.io/art-template/zh-cn/express/</a> </p></li><li><p>步骤1：安装art-template模板引擎</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install art-template</span><br><span class="line"></span><br><span class="line">npm install express-art-template</span><br></pre></td></tr></tbody></table></figure><p><img src="/medias/article/nodejs02/wps3.jpg" alt="img"> </p></li><li><p>步骤2：创建views目录（注：调用render方法默认会到views目录中找）</p></li><li><p>步骤3：创建test1.html文件（注：里面使用art-template模板语法）</p></li></ul><p><img src="/medias/article/nodejs02/wps4.jpg" alt="img"> </p><ul><li>步骤4：创建app2.js文件 -&gt; 启动并测试</li></ul><p><img src="/medias/article/nodejs02/wps5.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express框架模块</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">//2.创建框架核心app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//###声明所使用的模板引擎（ps. 使用render方法必须）</span><br><span class="line"></span><br><span class="line">app.engine('html', require('express-art-template'))</span><br><span class="line"></span><br><span class="line">//3.路由</span><br><span class="line"></span><br><span class="line">app.get('/',  function(req, res) {</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​//语法：res.render(模板文件, {数组})</span><br><span class="line"></span><br><span class="line">​//练习</span><br><span class="line"></span><br><span class="line">​res.render('test1.html', {</span><br><span class="line"></span><br><span class="line">​username: '传智播客',</span><br><span class="line"></span><br><span class="line">​age: 5,</span><br><span class="line"></span><br><span class="line">​orders: [</span><br><span class="line"></span><br><span class="line">​{id:1, title: '标题1', price: 30},</span><br><span class="line"></span><br><span class="line">​{id:2, title: '标题2', price: 33},</span><br><span class="line"></span><br><span class="line">​{id:3, title: '标题3', price: 12},</span><br><span class="line"></span><br><span class="line">​], </span><br><span class="line"></span><br><span class="line">​})</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//4.启动服务</span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('Running...')</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><ul><li><p>什么是路由：就是网址</p></li><li><p>什么是路由参数：就是网址参数</p></li><li><p>在  PHP中作用：声明交给哪个控制器的哪个方法处理</p></li><li><p>在NodeJS中作用：交给指定匿名函数处理</p></li></ul><h3 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a>2、语法</h3><ul><li>明   确：HTTP请求类型有get、post、put、delete等</li></ul><ol><li>普通语法：app.HTTP请求类型（请求路径，回调函数）</li></ol><ul><li><p>发送  GET请求：app.get（请求路径，回调函数）</p></li><li><p>发送POST请求：app.post（请求路径，回调函数）</p></li><li><p>发送  任意请求：app.all（请求路径，回调函数）</p></li><li><p>….</p></li></ul><ol start="2"><li>特殊语法：app.use（请求路径，回调函数）</li></ol><ul><li><p>区别1：use匹配任意类型请求</p></li><li><p>区别2：use非完全匹配（ps. 只需要url前面匹配请求路径即可匹配）</p></li></ul><ol start="3"><li>路由参数：app.HTTP请求类型（请求路径/:参数1/…/:参数n，回调函数）</li></ol><p><img src="/medias/article/nodejs02/wps6.jpg" alt="img"> </p><h3 id="3、练习（普通语法）"><a href="#3、练习（普通语法）" class="headerlink" title="3、练习（普通语法）"></a>3、练习（普通语法）</h3><ul><li>步骤1：创建app3.js文件，输入下述代码  （ps. 直接复制关键理解作用）</li></ul><p><img src="/medias/article/nodejs02/wps7.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express框架模块</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">//2.创建框架核心app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//3.路由</span><br><span class="line"></span><br><span class="line">app.get('/',  function(req, res) {</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​//注：修改method=get 或者 method=post查看结果</span><br><span class="line"></span><br><span class="line">​var formHtml = `</span><br><span class="line"></span><br><span class="line">​&lt;form action="/test" method="post"&gt;</span><br><span class="line"></span><br><span class="line">​&lt;input type="text" name="uname" /&gt;</span><br><span class="line"></span><br><span class="line">​&lt;input type="text" name="age" /&gt;</span><br><span class="line"></span><br><span class="line">​&lt;input type="submit"  /&gt;</span><br><span class="line"></span><br><span class="line">​&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">​`</span><br><span class="line"></span><br><span class="line">​res.send(formHtml)</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">app.get('/test', function(req, res){</span><br><span class="line"></span><br><span class="line">​res.send('this is get submit')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">app.post('/test', function(req, res){</span><br><span class="line"></span><br><span class="line">​res.send('this is post submit')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//4.启动服务</span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('Running...')</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>步骤2：测试</li></ul><h3 id="4、练习（特殊语法）"><a href="#4、练习（特殊语法）" class="headerlink" title="4、练习（特殊语法）"></a>4、练习（特殊语法）</h3><ul><li>步骤1：创建app4.js文件，输入下述代码  （ps. 直接复制关键理解作用）<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express框架模块</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">//2.创建框架核心app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//3.路由</span><br><span class="line"></span><br><span class="line">app.get('/',  function(req, res) {</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​var formHtml = `</span><br><span class="line"></span><br><span class="line">​&lt;form action="/test/a/b/c" method="post"&gt;</span><br><span class="line"></span><br><span class="line">​&lt;input type="text" name="uname" /&gt;</span><br><span class="line"></span><br><span class="line">​&lt;input type="text" name="age" /&gt;</span><br><span class="line"></span><br><span class="line">​&lt;input type="submit"  /&gt;</span><br><span class="line"></span><br><span class="line">​&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">​`</span><br><span class="line"></span><br><span class="line">​res.send(formHtml)</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">app.use('/test', function(req, res){</span><br><span class="line"></span><br><span class="line">​res.send('this is /test')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//4.启动服务</span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('Running...')</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li>步骤2：测试</li></ul><h3 id="3、练习（路由参数）"><a href="#3、练习（路由参数）" class="headerlink" title="3、练习（路由参数）"></a>3、练习（路由参数）</h3><ul><li>步骤1：创建app5.js文件，输入下述代码  （ps. 直接复制关键理解作用）<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express框架模块</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">//2.创建框架核心app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//3.路由</span><br><span class="line"></span><br><span class="line">app.get('/stu/:name/:age', function(req, res){</span><br><span class="line"></span><br><span class="line">​console.log(req.params);</span><br><span class="line"></span><br><span class="line">​res.send('匹配成功，快去看控制台有没有获取数据..')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//4.启动服务 </span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('Running...')</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li>步骤2：测试</li></ul><h2 id="五、利用-Express-托管静态文件"><a href="#五、利用-Express-托管静态文件" class="headerlink" title="五、利用 Express 托管静态文件"></a>五、利用 Express 托管静态文件</h2><ul><li>回忆：在第一讲中，让静态资源可以被外部访问</li></ul><p><img src="/medias/article/nodejs02/wps8.jpg" alt="img"> </p><ul><li><p>说明：在express中设置了固定语法允许指定目录下的文件被外部访问</p></li><li><p>练习：</p></li></ul><p><img src="/medias/article/nodejs02/wps9.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1.引入express框架模块</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">var fs = require('fs')</span><br><span class="line"></span><br><span class="line">//2.创建框架核心app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//3.路由</span><br><span class="line"></span><br><span class="line">// 指定文件</span><br><span class="line"></span><br><span class="line">// app.get('/public/css/test.css', function(req, res){</span><br><span class="line"></span><br><span class="line">// fs.readFile('./' + req.url, function(err,data){</span><br><span class="line"></span><br><span class="line">// res.send(data.toString())</span><br><span class="line"></span><br><span class="line">// })</span><br><span class="line"></span><br><span class="line">// })</span><br><span class="line"></span><br><span class="line">// 多个文件</span><br><span class="line"></span><br><span class="line">// app.use('/public', function(req, res){</span><br><span class="line"></span><br><span class="line">// fs.readFile('./public' + req.url, function(err,data){</span><br><span class="line"></span><br><span class="line">// res.send(data.toString())</span><br><span class="line"></span><br><span class="line">// })</span><br><span class="line"></span><br><span class="line">// })</span><br><span class="line"></span><br><span class="line">// 在express中</span><br><span class="line"></span><br><span class="line">// 作用：允许指定目录下的文件被外访问</span><br><span class="line"></span><br><span class="line">// 语法：express.static('目录名')  </span><br><span class="line"></span><br><span class="line">// 返回：一个函数，可理解为读取URL需要读取的文件</span><br><span class="line"></span><br><span class="line">app.use('/public', express.static('public'))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//4.启动服务</span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('Running...')</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="六、案例（留言板）"><a href="#六、案例（留言板）" class="headerlink" title="六、案例（留言板）"></a>六、案例（留言板）</h2><h3 id="1、效果图"><a href="#1、效果图" class="headerlink" title="1、效果图"></a>1、效果图</h3><p><img src="/medias/article/nodejs05/wps1.jpg" alt="img">  <img src="/medias/article/nodejs05/wps2.jpg" alt="img"></p><h3 id="2、初始化"><a href="#2、初始化" class="headerlink" title="2、初始化"></a>2、初始化</h3><ul><li>步骤1：创建如下结构目录</li></ul><p><img src="/medias/article/nodejs05/wps3.jpg" alt="img"> </p><ul><li>步骤2：将静态资源和静态文件复制到对应目录中</li></ul><p><img src="/medias/article/nodejs05/wps4.jpg" alt="img"> </p><ul><li>步骤3：执行下述命令<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">npm install express</span><br><span class="line"></span><br><span class="line">npm install art-template</span><br><span class="line"></span><br><span class="line">npm install express-art-template</span><br></pre></td></tr></tbody></table></figure><img src="/medias/article/nodejs05/wps5.jpg" alt="img"> </li></ul><p><img src="/medias/article/nodejs05/wps6.jpg" alt="img"> </p><h3 id="3、显示静态页面"><a href="#3、显示静态页面" class="headerlink" title="3、显示静态页面"></a>3、显示静态页面</h3><ul><li>创建app.js文件</li></ul><p><img src="/medias/article/nodejs05/wps7.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express框架模块</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">var fs = require('fs')</span><br><span class="line"></span><br><span class="line">//2.创建框架核心app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//3.配置框架</span><br><span class="line"></span><br><span class="line">app.use('/public', express.static('public'))</span><br><span class="line"></span><br><span class="line">app.engine('html', require('express-art-template'))</span><br><span class="line"></span><br><span class="line">//4.路由</span><br><span class="line"></span><br><span class="line">app.get('/', function(req, res){</span><br><span class="line"></span><br><span class="line">//首页</span><br><span class="line"></span><br><span class="line">​return res.render('index.html')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.get('/post', function(req, res){</span><br><span class="line"></span><br><span class="line">//添加页</span><br><span class="line"></span><br><span class="line">​return res.render('post.html')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.get('/dopost', function(req, res){</span><br><span class="line"></span><br><span class="line">//添加数据处理</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//5.启动服务</span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('Running...')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="4、显示动态页面"><a href="#4、显示动态页面" class="headerlink" title="4、显示动态页面"></a>4、显示动态页面</h3><ul><li>步骤1：声明留言数据变量</li></ul><p><img src="/medias/article/nodejs05/wps8.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建留言数据对象</span><br><span class="line"></span><br><span class="line">var msgs = [</span><br><span class="line"></span><br><span class="line"> {name: '张三', content: "你好我是张三", create_at: '2017-11-14 10:30:32'},</span><br><span class="line"></span><br><span class="line"> {name: '李四', content: "你好我是李四", create_at: '2017-11-15 10:11:14'},</span><br><span class="line"></span><br><span class="line"> {name: '王五', content: "你好我是王五", create_at: '2017-11-16 10:22:55'}</span><br><span class="line"></span><br><span class="line">];</span><br></pre></td></tr></tbody></table></figure><ul><li>步骤2：传递给视图</li></ul><p><img src="/medias/article/nodejs05/wps9.jpg" alt="img"> </p><ul><li>步骤3：视图遍历 -&gt; 查看效果</li></ul><p><img src="/medias/article/nodejs05/wps10.jpg" alt="img"> </p><h3 id="5、数据处理（get）"><a href="#5、数据处理（get）" class="headerlink" title="5、数据处理（get）"></a>5、数据处理（get）</h3><ul><li>步骤1：修改post.html文件</li></ul><p><img src="/medias/article/nodejs05/wps11.jpg" alt="img"> </p><ul><li>步骤2：修改app.js增加逻辑判断</li></ul><p><img src="/medias/article/nodejs05/wps12.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//创建留言数据对象</span><br><span class="line"></span><br><span class="line">var msgs = [</span><br><span class="line"></span><br><span class="line"> {name: '张三', content: "你好我是张三", create_at: '2017-11-14 10:30:32'},</span><br><span class="line"></span><br><span class="line"> {name: '李四', content: "你好我是李四", create_at: '2017-11-15 10:11:14'},</span><br><span class="line"></span><br><span class="line"> {name: '王五', content: "你好我是王五", create_at: '2017-11-16 10:22:55'}</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//1.引入express框架</span><br><span class="line"></span><br><span class="line">var url = require('url')</span><br><span class="line"></span><br><span class="line">var moment = require('moment');</span><br><span class="line"></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line">//2.创建app对象</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//3.配置</span><br><span class="line"></span><br><span class="line">app.engine('html', require('express-art-template'))</span><br><span class="line"></span><br><span class="line">app.use('/public', express.static('public'))</span><br><span class="line"></span><br><span class="line">//4.路由</span><br><span class="line"></span><br><span class="line">//#留言列表</span><br><span class="line"></span><br><span class="line">app.get('/', function(req, res){</span><br><span class="line"></span><br><span class="line">​res.render('index.html', {</span><br><span class="line"></span><br><span class="line">​msgs: msgs</span><br><span class="line"></span><br><span class="line">​})</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//#留言添加</span><br><span class="line"></span><br><span class="line">app.get('/add', function(req, res){</span><br><span class="line"></span><br><span class="line">​res.render('add.html')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//#留言添加处理</span><br><span class="line"></span><br><span class="line">app.get('/doadd', function(req, res){</span><br><span class="line"></span><br><span class="line">​//数据处理</span><br><span class="line"></span><br><span class="line">​//1.接受参数</span><br><span class="line"></span><br><span class="line">​var paramObj = url.parse(req.url, true).query</span><br><span class="line"></span><br><span class="line">​//2.入库（压入）</span><br><span class="line"></span><br><span class="line">​var date = moment().format("YYYY-MM-D h:mm:ss");</span><br><span class="line"></span><br><span class="line">​var msg = {name:paramObj.name, content: paramObj.content, create_at: date}</span><br><span class="line"></span><br><span class="line">​msgs.push(msg)</span><br><span class="line"></span><br><span class="line">​//3.跳转</span><br><span class="line"></span><br><span class="line">​res.redirect('/')</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//5.启动服务</span><br><span class="line"></span><br><span class="line">app.listen(8080, function(){</span><br><span class="line"></span><br><span class="line">​console.log('启动成功，访问：http://localhost')</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>步骤3：测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs之常用第三方模块</title>
      <link href="/2021/08/03/nodejs-zhi-chang-yong-di-san-fang-mo-kuai/"/>
      <url>/2021/08/03/nodejs-zhi-chang-yong-di-san-fang-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="1-nodemon自动重启服务（热部署）"><a href="#1-nodemon自动重启服务（热部署）" class="headerlink" title="1.nodemon自动重启服务（热部署）"></a>1.nodemon自动重启服务（热部署）</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h3><p>发现：每次修改代码都得重新启动服务，增加工作量<br>解决：通过nodemon检测文件修改自动重启</p><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2.使用"></a>1.2.使用</h3><ul><li>步骤1：初始化项目（ps. 自动创建package.json文件，作用：描述项目依赖）</li></ul><p><img src="/medias/article/nodejs04/wps16.jpg" alt="img"> </p><ul><li>步骤1：安装（npm install nodemon –save-dev -g）</li></ul><p><img src="/medias/article/nodejs04/wps17.jpg" alt="img"> </p><ul><li>步骤2：通过nodemon启动服务 -&gt; 测试</li></ul><p><img src="/medias/article/nodejs04/wps18.jpg" alt="img"> </p><h2 id="2-moment日期处理模块"><a href="#2-moment日期处理模块" class="headerlink" title="2.moment日期处理模块"></a>2.moment日期处理模块</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>发现：通过昨天项目发现，发现日期代码太长，切不便记忆<br>解决：自己封装模块或使用第三方模块（<a href="http://momentjs.cn/%EF%BC%89">http://momentjs.cn/）</a></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><ul><li>步骤1：初始化项目（ps. 自动创建package.json文件，作用：描述项目依赖）</li></ul><p><img src="/medias/article/nodejs04/wps19.jpg" alt="img"> </p><ul><li>步骤2：安装（npm  install moment）</li></ul><p><img src="/medias/article/nodejs04/wps20.jpg" alt="img"> </p><ul><li>步骤3：测试</li></ul><p><img src="/medias/article/nodejs04/wps21.jpg" alt="img"> </p><h2 id="3-Jade-ejs-art模板引擎-（第三方模块）"><a href="#3-Jade-ejs-art模板引擎-（第三方模块）" class="headerlink" title="3.Jade/ejs/art模板引擎  （第三方模块）"></a>3.Jade/ejs/art模板引擎  （第三方模块）</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><ul><li>模板引擎：名词</li></ul><ol><li><p> 在  PHP中，就是一个类，将视图标签替换成对应数据，生成新的HTML页面</p></li><li><p> 在NodeJS中，就是一个模块，将视图标签替换成对应数据，生成新的HTML页面</p></li></ol><ul><li>模板引擎测速</li></ul><p><img src="/medias/article/nodejs03/wps1.jpg" alt="img"> </p><h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p><img src="/medias/article/nodejs03/wps2.jpg" alt="img"> </p><h3 id="3、ejs"><a href="#3、ejs" class="headerlink" title="3、ejs"></a>3、ejs</h3><ul><li><p>语 法：<a href="https://www.npmjs.com/package/ejs">https://www.npmjs.com/package/ejs</a> </p></li><li><p>步骤1：安装（npm install ejs）</p></li></ul><p><img src="/medias/article/nodejs03/wps3.jpg" alt="img"> </p><ul><li>步骤2：创建ejs.js和ejs.html测试</li></ul><p><img src="/medias/article/nodejs03/wps4.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//1.引入第三方模块EJS</span><br><span class="line"></span><br><span class="line">var ejs = require('ejs');</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//2.调用render方法，将字符串替换成HTML</span><br><span class="line"></span><br><span class="line">// var html = '&lt;h1&gt;&lt;%= username %&gt;&lt;/h1&gt;';</span><br><span class="line"></span><br><span class="line">// var result = ejs.render(html, {username: '张三'});</span><br><span class="line"></span><br><span class="line">// console.log(result);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//2.调用renderFile方法，将字符串替换成HTML</span><br><span class="line"></span><br><span class="line">ejs.renderFile('./ejs.html', {</span><br><span class="line"></span><br><span class="line">​username: '传智播客',</span><br><span class="line"></span><br><span class="line">​age: 5,</span><br><span class="line"></span><br><span class="line">​orders: [</span><br><span class="line"></span><br><span class="line">​{id:1, title: '标题1', price: 30},</span><br><span class="line"></span><br><span class="line">​{id:2, title: '标题2', price: 33},</span><br><span class="line"></span><br><span class="line">​{id:3, title: '标题3', price: 12},</span><br><span class="line"></span><br><span class="line">​], </span><br><span class="line"></span><br><span class="line">​}, </span><br><span class="line"></span><br><span class="line">​function(err, str) {</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">​if (err) {</span><br><span class="line"></span><br><span class="line">​console.log(err)</span><br><span class="line"></span><br><span class="line">​return</span><br><span class="line"></span><br><span class="line">​}</span><br><span class="line"></span><br><span class="line">​console.log(str);</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line"></span><br><span class="line">​&lt;title&gt;视图&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;&lt;%= username %&gt;&lt;/h1&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;&lt;%= age %&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;</span><br><span class="line"></span><br><span class="line">​ &lt;% if (age&gt;18) { %&gt;</span><br><span class="line"></span><br><span class="line">​妹妹哥哥来了</span><br><span class="line"></span><br><span class="line">​&lt;% } else { %&gt;</span><br><span class="line"></span><br><span class="line">​你走吧</span><br><span class="line"></span><br><span class="line">​&lt;% } %&gt;</span><br><span class="line"></span><br><span class="line">​ &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;</span><br><span class="line"></span><br><span class="line">​&lt;% orders.forEach(function(order,index) { %&gt;</span><br><span class="line"></span><br><span class="line">​&lt;%= index %&gt; &lt;%= order.title %&gt;</span><br><span class="line"></span><br><span class="line">​&lt;% }) %&gt;</span><br><span class="line"></span><br><span class="line">​ &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="4、Jade"><a href="#4、Jade" class="headerlink" title="4、Jade"></a>4、Jade</h3><ul><li><p>语 法：<a href="http://jade-lang.com/api">http://jade-lang.com/api</a> </p></li><li><p>步骤1：安装（npm install jade）</p></li></ul><p><img src="/medias/article/nodejs03/wps5.jpg" alt="img"> </p><ul><li>步骤2：创建jade.js和jade.html测试</li></ul><p><img src="/medias/article/nodejs03/wps6.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1.引入第三方模块JADE</span><br><span class="line"></span><br><span class="line">var jade = require('jade');</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//2.调用render方法，将字符串替换成HTML</span><br><span class="line"></span><br><span class="line">// var html = '&lt;h1&gt;#{uname} &lt;/h1&gt;';</span><br><span class="line"></span><br><span class="line">// var result = jade.render(html, {uname: '张三'});</span><br><span class="line"></span><br><span class="line">// console.log(result);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//2.调用renderFile方法，将字符串替换成HTML</span><br><span class="line"></span><br><span class="line">var html = jade.renderFile('jade.html', {</span><br><span class="line"></span><br><span class="line">​username: '传智播客',</span><br><span class="line"></span><br><span class="line">​age: 5,</span><br><span class="line"></span><br><span class="line">​orders: [</span><br><span class="line"></span><br><span class="line">​{id:1, title: '标题1', price: 30},</span><br><span class="line"></span><br><span class="line">​{id:2, title: '标题2', price: 33},</span><br><span class="line"></span><br><span class="line">​{id:3, title: '标题3', price: 12},</span><br><span class="line"></span><br><span class="line">​], </span><br><span class="line"></span><br><span class="line">​pretty: true</span><br><span class="line"></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log(html);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">doctype html</span><br><span class="line"></span><br><span class="line">html</span><br><span class="line"></span><br><span class="line">​head</span><br><span class="line"></span><br><span class="line">​meta(charset='utf-8')</span><br><span class="line"></span><br><span class="line">​body</span><br><span class="line"></span><br><span class="line">​//  注释会显示 </span><br><span class="line"></span><br><span class="line">​//- 注释不显示</span><br><span class="line"></span><br><span class="line">​HTML标签语法： &lt;标签名 属性n=属性值n&gt;内容&lt;/标签名&gt;</span><br><span class="line"></span><br><span class="line">​jade模板规则：</span><br><span class="line"></span><br><span class="line">​标签名直接写</span><br><span class="line"></span><br><span class="line">​括号里面是属性</span><br><span class="line"></span><br><span class="line">​class用数组写法</span><br><span class="line"></span><br><span class="line">​-标识js代码</span><br><span class="line"></span><br><span class="line">​#{变量名}  输出数据</span><br><span class="line"></span><br><span class="line">​等</span><br><span class="line"></span><br><span class="line">​div(id='div1',style='width:300px;height:30px;background:red;') hello div1</span><br><span class="line"></span><br><span class="line">​div(class='div2') hello div2</span><br><span class="line"></span><br><span class="line">​div(class=['div3','div']) hello div3</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​p</span><br><span class="line"></span><br><span class="line">​- var a= 1</span><br><span class="line"></span><br><span class="line">​- var b= 1</span><br><span class="line"></span><br><span class="line">​p 计算结果是：#{a+b}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​p 用户名：#{username}，年龄：#{age}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​- if (age &gt; 18)</span><br><span class="line"></span><br><span class="line">​p 111</span><br><span class="line"></span><br><span class="line">​- else</span><br><span class="line"></span><br><span class="line">​p 222</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​- for (index in orders)</span><br><span class="line"></span><br><span class="line">​p #{index} __ #{orders[index].title}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​ul</span><br><span class="line"></span><br><span class="line">​- each order, index in orders</span><br><span class="line"></span><br><span class="line">​li #{index} __ + #{order.title}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="5、art（推荐）"><a href="#5、art（推荐）" class="headerlink" title="5、art（推荐）"></a>5、art（推荐）</h3><ul><li><p>语 法：<a href="https://aui.github.io/art-template/zh-cn/docs/index.html">https://aui.github.io/art-template/zh-cn/docs/index.html</a> </p></li><li><p>步骤1：安装（npm install art-template）</p></li></ul><p><img src="/medias/article/nodejs03/wps7.jpg" alt="img"> </p><ul><li>步骤2：创建art.js和art.html测试</li></ul><p><img src="/medias/article/nodejs03/wps8.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">//1.引入第三方模块ART</span><br><span class="line"></span><br><span class="line">var art = require('art-template');</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//2.调用render方法，将字符串替换成HTML</span><br><span class="line"></span><br><span class="line">// var html = '&lt;h1&gt;{{username}}&lt;/h1&gt;';</span><br><span class="line"></span><br><span class="line">// var result = art.render(html, {username: '张三'});</span><br><span class="line"></span><br><span class="line">// console.log(result);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//2.调用art（同renderFile），将字符串替换成HTML</span><br><span class="line"></span><br><span class="line">var html = art(__dirname + '/art.html', {</span><br><span class="line"></span><br><span class="line">​username: '传智播客',</span><br><span class="line"></span><br><span class="line">​age: 5,</span><br><span class="line"></span><br><span class="line">​orders: [</span><br><span class="line"></span><br><span class="line">​{id:1, title: '标题1', price: 30},</span><br><span class="line"></span><br><span class="line">​{id:2, title: '标题2', price: 33},</span><br><span class="line"></span><br><span class="line">​{id:3, title: '标题3', price: 12},</span><br><span class="line"></span><br><span class="line">​], </span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">console.log(html);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line"></span><br><span class="line">​&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;{{username}}&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;{{age}}&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;</span><br><span class="line"></span><br><span class="line">​ {{if age &gt; 18}}</span><br><span class="line"></span><br><span class="line">​妹妹哥哥来了</span><br><span class="line"></span><br><span class="line">​{{else}}</span><br><span class="line"></span><br><span class="line">​你走吧</span><br><span class="line"></span><br><span class="line">​{{/if}}</span><br><span class="line"></span><br><span class="line">​ &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&nbsp;&lt;div&gt;</span><br><span class="line"></span><br><span class="line">​ {{each orders as order index}}</span><br><span class="line"></span><br><span class="line">​  {{index}} {{order.title}}</span><br><span class="line"></span><br><span class="line">​{{/each}}</span><br><span class="line"></span><br><span class="line">​ &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven以及npm依赖查找</title>
      <link href="/2021/08/03/maven-yi-ji-npm-yi-lai-cha-zhao/"/>
      <url>/2021/08/03/maven-yi-ji-npm-yi-lai-cha-zhao/</url>
      
        <content type="html"><![CDATA[<ol><li>maven仓库：<br><a href="https://mvnrepository.com/">mvnrepository</a></li><li>npm仓库：<br><a href="https://www.npmjs.com/">npmjs</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs之npm</title>
      <link href="/2021/08/03/nodejs-zhi-npm/"/>
      <url>/2021/08/03/nodejs-zhi-npm/</url>
      
        <content type="html"><![CDATA[<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol><li>npm工具的使用</li><li>学习express框架使用</li><li>完成留言板案例(express)<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3>能够理解npm的作用<br>能够使用npm安装（添加）第三方模块<br>能够使用npm删除（卸载）第三方模块<br>能够理解package.json文件的作用<br>能够安装moment（日期）第三方模块<br>能够理解模板引擎的作用<br>能够使用npm安装express框架<br>能够使用express建立http服务器<h2 id="1-npm简介"><a href="#1-npm简介" class="headerlink" title="1.npm简介"></a>1.npm简介</h2></li><li>是什么？<br>是一个命令行工具（node package manager）</li><li>能干吗？<br>下载node所需要的第三方模块</li><li>安装Node js自带npm所以直接使用<h2 id="2-NPM语法"><a href="#2-NPM语法" class="headerlink" title="2.NPM语法"></a>2.NPM语法</h2><h3 id="2-1命令"><a href="#2-1命令" class="headerlink" title="2.1命令"></a>2.1命令</h3></li><li>查看：npm list</li><li>安装：npm install  模块或@版本号 [安装可选参数]</li><li>卸载：npm uninstall 模块<h3 id="2-2安装参数"><a href="#2-2安装参数" class="headerlink" title="2.2安装参数"></a>2.2安装参数</h3></li><li>–save 记录生产环境所需模块（默认）</li><li>–save-dev 记录开发环境所需模块</li><li>-g 该模块可在命令行运行 (global)     npm config list查看全局目录所在位置<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多学一招：</span><br><span class="line">都安装:npminstall</span><br><span class="line">只安装生产环境:npm install --production</span><br></pre></td></tr></tbody></table></figure><h2 id="3-NPM使用"><a href="#3-NPM使用" class="headerlink" title="3.NPM使用"></a>3.NPM使用</h2><h3 id="3-1初体验"><a href="#3-1初体验" class="headerlink" title="3.1初体验"></a>3.1初体验</h3></li><li>复习：MIME是一个规则，类型text/html-.html文件、image/png-png文件等</li><li>需求：安装mime模块 （ps.该模块用户判断mime类型）</li></ol><hr><ol><li>明确：npm是nodejs项目模块管理工具</li><li>使用：1-初始化项目，2-安装/卸载模块</li></ol><hr><ol><li>步骤1：初始化项目（ps.自动创建package.json文件，作用：描述项目一依赖）<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></tbody></table></figure></li><li>步骤2：安装<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [xxx]</span><br></pre></td></tr></tbody></table></figure></li><li>步骤3：使用<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.引入第三方模块</span><br><span class="line">var mime = require('mime');</span><br><span class="line"> </span><br><span class="line">//2.调用方法测试</span><br><span class="line">var img = 'xxxx.png';</span><br><span class="line">var imgMimeType = mime.getType(img);</span><br><span class="line">var imgType = mime.getExtension(imgMimeType);</span><br><span class="line">console.log(imgMimeType);     </span><br><span class="line">console.log(imgType);  </span><br></pre></td></tr></tbody></table></figure><h3 id="3-2安装参数作用"><a href="#3-2安装参数作用" class="headerlink" title="3.2安装参数作用"></a>3.2安装参数作用</h3></li></ol><ul><li><p>发现1：上面默认不加任何参数安装mime，命令行不可以直接使用</p></li><li><p>解 决：加上-g重新安装</p></li></ul><p><img src="/medias/article/nodejs/wps1.jpg" alt="img"> </p><ul><li>发现2：默认install不加参数则属于生成环境模块</li></ul><p><img src="/medias/article/nodejs/wps2.jpg" alt="img"> </p><ul><li>测试：参数–save-dev代表开发环境</li></ul><p><img src="/medias/article/nodejs/wps3.jpg" alt="img"> </p><ul><li>发现3：安装模块加–production参数则生产环境，否则全部安装</li></ul><p><img src="/medias/article/nodejs/wps4.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps5.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps6.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps7.jpg" alt="img"> </p><h2 id="4-npm模块版本控制"><a href="#4-npm模块版本控制" class="headerlink" title="4.npm模块版本控制"></a>4.npm模块版本控制</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">科普软件版本含义：</span><br><span class="line">aplha版   - 内测版（功能不全，BUG多）</span><br><span class="line">beta版    - 公测版（功能不全，发骚友准备，依旧存在BUG）</span><br><span class="line">rc版      - 预览版（功能不再增加）</span><br><span class="line">stable版  - 用户可用</span><br><span class="line">===================</span><br><span class="line">主版本号.次版本号.修改版本号</span><br><span class="line"></span><br><span class="line">主版本：功能模块有大的变动，比如增加多个模块或者整体架构发生变化</span><br><span class="line">次版本：次版本号的升级对应的只是局部的变动</span><br><span class="line">修改版：BUG修复或者功能的扩充等</span><br><span class="line"></span><br><span class="line">~用户使用该版本后，最多升级到【修改版】最新</span><br><span class="line">^用户使用该版本后，最多升级到【次版本】最新</span><br><span class="line">*用户使用该版本后，可以升级到最新版本</span><br></pre></td></tr></tbody></table></figure><h2 id="5-npm源管理"><a href="#5-npm源管理" class="headerlink" title="5.npm源管理"></a>5.npm源管理</h2><ul><li>明确：通过npm命令下载会到国外服务器获取</li><li>缺点：下载速度慢</li><li>解决：切换国内服务器</li></ul><hr><ul><li><p>简介：nrm是资源管理工具，可以切换国内服务器下载</p></li><li><p>命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装：npm install nrm -g</span><br><span class="line">查看：nrm ls              （注：单词list缩写，查看可用服务器）</span><br><span class="line">切换：nrm use 服务器名</span><br><span class="line">测速：nrm test</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用</p><ol><li>步骤1：安装</li></ol><p><img src="/medias/article/nodejs/wps8.jpg" alt="img"> </p><ol start="2"><li>步骤2：查看 -&gt; 测速 -&gt; 切换 -&gt; 验证</li></ol><p><img src="/medias/article/nodejs/wps9.jpg" alt="img"> </p></li></ul><h2 id="6-NPM自定义脚本命令-重点-难点"><a href="#6-NPM自定义脚本命令-重点-难点" class="headerlink" title="6.NPM自定义脚本命令(重点.难点)"></a>6.NPM自定义脚本命令(重点.难点)</h2><ul><li><p>思考：后期启动项目需要敲很长的命令，如何简化？</p></li><li><p>解决：通过修改package.json文件的scripts自定义脚本命令</p></li></ul><hr><ul><li><p>语法：npm  run 名称    （ps. 1-名称指scripts中的键 2-如果是start则run可省略）</p></li><li><p>练习：运行a输出666</p></li></ul><p><img src="/medias/article/nodejs/wps10.jpg" alt="img"> </p><ul><li>练习：通过start运行mime_test.js文件</li></ul><p><img src="/medias/article/nodejs/wps11.jpg" alt="img"> </p><h2 id="7-NPM包自定义包发布（理解）"><a href="#7-NPM包自定义包发布（理解）" class="headerlink" title="7.NPM包自定义包发布（理解）"></a>7.NPM包自定义包发布（理解）</h2><p>模块：在node中就是一个文件<br>包：N个模块、目录、package.json等组成，然后发布，让别人require</p><hr><p>需 求：发布itcast-php-teacher包</p><ul><li>步骤1：创建day22开发目录 -&gt; 初始化 -&gt; 修改package.json文件</li></ul><p><img src="/medias/article/nodejs/wps12.jpg" alt="img"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fn = {</span><br><span class="line"></span><br><span class="line">​name: 'phpopenfather',</span><br><span class="line"></span><br><span class="line">​school: 'php@itcast',</span><br><span class="line"></span><br><span class="line">​say: function() {</span><br><span class="line"></span><br><span class="line">​console.log('悟空');</span><br><span class="line"></span><br><span class="line">​}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module.exports = fn</span><br></pre></td></tr></tbody></table></figure><ul><li><p> 步骤2：打开npmjs.com注册账号</p></li><li><p>步骤3：本地登录提交（切记提交自己的包必须切换到国外服务器，下载在切换过来）</p></li></ul><p><img src="/medias/article/nodejs/wps13.jpg" alt="img"> </p><ul><li>步骤4：测试（创建day23开发目录，执行命令npm install itcast-php-teacher）</li></ul><p><img src="/medias/article/nodejs/wps14.jpg" alt="img"> </p><p><img src="/medias/article/nodejs/wps15.jpg" alt="img"> </p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>什么是NMP：就是一个工具，用于管理项目所需依赖</p><p>语法：npm install/uninstall 模块/包（ps. -g命令行执行/全局目录  –save-dev开发环境）</p><p>服务器加速：通过nrm工具</p><p>自定义脚本命令：修改package.json的scripts键即可</p><p>自定义发布：node login  &amp;  node publish </p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01nodejs入门</title>
      <link href="/2021/08/01/nodejs-ru-men/"/>
      <url>/2021/08/01/nodejs-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-初体验（REPL）"><a href="#1-初体验（REPL）" class="headerlink" title="1.初体验（REPL）"></a>1.初体验（REPL）</h2><ol><li>R(read) 读取（读取用户输入的代码）</li><li>E(exec) 执行 （执行用户输入的代码）</li><li>P(print) 打印（打印用户输入的js代码）</li><li>L(loop) 循环 (后续所有js代码执行都会循环以上命令)</li><li>退出：ctrl+c<h3 id="1-1通过命令行运行js代码"><a href="#1-1通过命令行运行js代码" class="headerlink" title="1.1通过命令行运行js代码"></a>1.1通过命令行运行js代码</h3></li><li>命令行输入node启动node后直接输入js代码</li><li>命令行node xx.js运行js文件<br>（cls清屏）<h2 id="2-模块系统"><a href="#2-模块系统" class="headerlink" title="2.模块系统"></a>2.模块系统</h2>js三大组成部分：</li><li>ecmascript(声明js变量，判断，循环等语法)</li><li>dom(document)</li><li>BOM(window，local等)<br>模块(http服务器等)<h3 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h3><h3 id="2-1-1使用Nodejs编写应用程序主要使用"><a href="#2-1-1使用Nodejs编写应用程序主要使用" class="headerlink" title="2.1.1使用Nodejs编写应用程序主要使用"></a>2.1.1使用Nodejs编写应用程序主要使用</h3></li></ol><ul><li>ecmascript语法：变量、判断、循环等（js三大组成部分：ECMA/DOM/BOM）</li><li>内置核心模块：http服务、fs文件操作、url路径、path路径处理、os操作系统</li><li>第三方模块：</li><li>自定义模块：自己创建的js文件<h3 id="2-2-2CommonJS模块模范"><a href="#2-2-2CommonJS模块模范" class="headerlink" title="2.2.2CommonJS模块模范"></a>2.2.2CommonJS模块模范</h3></li><li>一个文件就是一个模块</li><li>通过require来加载模块</li><li>通过exports和modul.exports来到导出模块中的成员（声明模块中哪些功能可以使用）<h3 id="2-2自定义Node-js模块"><a href="#2-2自定义Node-js模块" class="headerlink" title="2.2自定义Node.js模块"></a>2.2自定义Node.js模块</h3><h3 id="2-2-1语法"><a href="#2-2-1语法" class="headerlink" title="2.2.1语法"></a>2.2.1语法</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">步骤1：导出成员（声明模块中/文件中哪些方法可以被外部使用）</span><br><span class="line">//写法1</span><br><span class="line">exports.属性/方法名=功能</span><br><span class="line">//写法2</span><br><span class="line">module.exports.属性/方法名=变量名</span><br><span class="line">步骤2：外部引入使用</span><br><span class="line">//使用：先引入再调用</span><br><span class="line">var 对象=require('路径及文件名')</span><br><span class="line">对象.属性或方法名</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img src="/medias/article/nodejs/image-20210801202634827.png" alt="image-20210801202634827"></p><h3 id="2-3第三方模块"><a href="#2-3第三方模块" class="headerlink" title="2.3第三方模块"></a>2.3第三方模块</h3><h3 id="2-4Node-js内置模块"><a href="#2-4Node-js内置模块" class="headerlink" title="2.4Node.js内置模块"></a>2.4Node.js内置模块</h3><p><a href="https://github.com/nodejs/node/tree/master/lib">内置模块</a><br><a href="http://nodejs.cn/api/">api手册</a></p><h4 id="2-4-1获取操作系统信息（os模块）-–了解"><a href="#2-4-1获取操作系统信息（os模块）-–了解" class="headerlink" title="2.4.1获取操作系统信息（os模块）  –了解"></a>2.4.1获取操作系统信息（os模块）  –了解</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 字节是计算机中的一种计量单位，表示数据量的多少 </span><br><span class="line">// 1字节（Byte）= 8位（bit）</span><br><span class="line">// 1KB = 1024Byte（字节）</span><br><span class="line">// 1MB = 1024KB</span><br><span class="line">// 1GB =  1024MB</span><br><span class="line">// 1TB =  1024GB</span><br><span class="line"></span><br><span class="line">//1.创建os对象（引入nodejs内置os模块）</span><br><span class="line">var os = require("os");</span><br><span class="line">//2.调用os对象方法获取系统数据</span><br><span class="line">console.log('hello，另起一行' + os.EOL    + 'itcast');</span><br><span class="line">console.log('主机名: ' + os.hostname());</span><br><span class="line">console.log('操作系统名: '  + os.type());</span><br><span class="line">console.log('操作系统平台: ' + os.platform());</span><br><span class="line">console.log('内存总量: '  + os.totalmem() + " 字节.");</span><br><span class="line">console.log('空闲内存: '  + os.freemem() + " 字节.");</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-2路径处理（path模块）"><a href="#2-4-2路径处理（path模块）" class="headerlink" title="2.4.2路径处理（path模块）"></a>2.4.2路径处理（path模块）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//dirname  去最后一个</span><br><span class="line">//basename 取最后一个</span><br><span class="line"></span><br><span class="line">//1.创建path对象（引入nodejs内置path模块）</span><br><span class="line">var path = require("path");</span><br><span class="line">//2.调用path对象方法</span><br><span class="line">var testData = 'c:/app/view/godos/add.html';</span><br><span class="line">console.log(path.extname(testData)); //取后缀（包括.）</span><br><span class="line">console.log(path.basename(testData));//取最后一层</span><br><span class="line">console.log(path.dirname(testData)); //去最后一层</span><br><span class="line">console.log(path.dirname(path.dirname(testData)));</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-3网址处理（url模块）"><a href="#2-4-3网址处理（url模块）" class="headerlink" title="2.4.3网址处理（url模块）"></a>2.4.3网址处理（url模块）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.创建url对象（引入nodejs内置url模块）</span><br><span class="line">var url = require("url");</span><br><span class="line">//2.调用url对象方法</span><br><span class="line">var wangzhi = "http://itcast.cn?name=张三&amp;age=18";</span><br><span class="line">console.log(url.parse(wangzhi)); //解析网址</span><br><span class="line">console.log(url.parse(wangzhi, true)); //解析网址参数为对象</span><br><span class="line"></span><br><span class="line">var param = url.parse(wangzhi, true).query;</span><br><span class="line">console.log(param);</span><br><span class="line">console.log(param.name);</span><br><span class="line">console.log(param.age);</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-4文件处理（fs模块）"><a href="#2-4-4文件处理（fs模块）" class="headerlink" title="2.4.4文件处理（fs模块）"></a>2.4.4文件处理（fs模块）</h4><h5 id="2-4-4-1写入文件"><a href="#2-4-4-1写入文件" class="headerlink" title="2.4.4.1写入文件"></a>2.4.4.1写入文件</h5><p>语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1.创建fs对象（引入node内置的fs模块）</span><br><span class="line">var fs = require('fs');</span><br><span class="line"></span><br><span class="line">//2.调用函数写数据进文件</span><br><span class="line">fs.writeFile(路径及文件名，数据，function(err){</span><br><span class="line">    err  为null - 则写入成功</span><br><span class="line">    err不为null - 则写入失败</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>练习：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1.创建fs对象（引入node内置的fs模块）</span><br><span class="line">var fs = require('fs');</span><br><span class="line"></span><br><span class="line">//2.调用函数写数据进文件</span><br><span class="line">fs.writeFile('./a.txt', '你好，hybs', function(err) {</span><br><span class="line">    // err  为null - 则写入成功</span><br><span class="line">    // err不为null - 则写入失败</span><br><span class="line">    if (err) {</span><br><span class="line">    console.log(err);</span><br><span class="line">    return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    console.log('写入成功');</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="2-4-4-2读取文件"><a href="#2-4-4-2读取文件" class="headerlink" title="2.4.4.2读取文件"></a>2.4.4.2读取文件</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile('../../data/data01.txt', 'utf-8', function(err,data) {    //不加解码类型会是buffer对象</span><br><span class="line">    // err  为null - 则写入成功</span><br><span class="line">    // err不为null - 则写入失败</span><br><span class="line">    if (err) {</span><br><span class="line">        console.log(err);</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">    console.log(data)</span><br><span class="line">    console.log('读取成功');</span><br><span class="line">    console.log(data.toString())   //通过buffer.tostring()转化为string类型</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-5引入http服务器并创建服务器"><a href="#2-4-5引入http服务器并创建服务器" class="headerlink" title="2.4.5引入http服务器并创建服务器"></a>2.4.5引入http服务器并创建服务器</h4><ol><li>创建http服务器<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//说明</span><br><span class="line">//nodejs作用：1-提供JS运行环境，2-提供N多模块(API)让JS更强大</span><br><span class="line"></span><br><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求</span><br><span class="line">server.on('request', function() {</span><br><span class="line">console.log('收到客户端请求了');</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li>响应数据<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求（形参：request-请求对象，response-响应对象）</span><br><span class="line">server.on('request', function(request, response) {</span><br><span class="line">//有请求DOS窗口就输出</span><br><span class="line">console.log('收到客户端请求了，请求路径是：' + request.url);</span><br><span class="line">//响应请求</span><br><span class="line">//write方法：声明给客户端发送的数据</span><br><span class="line">//end方法：  结束响应</span><br><span class="line">response.write('hello,');</span><br><span class="line">response.write('itcast');</span><br><span class="line">response.end();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li>响应不同数据<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求（形参：request-请求对象，response-响应对象）</span><br><span class="line">server.on('request', function(request, response) {</span><br><span class="line"></span><br><span class="line">//获取请求路径（注：默认请求站点根目录）</span><br><span class="line">var url = request.url;</span><br><span class="line">//判断请求路径</span><br><span class="line">if (url == '/') {</span><br><span class="line">var content = 'this is index';</span><br><span class="line">} else if (url == '/login') {</span><br><span class="line">var content = 'this is login';</span><br><span class="line">} else {</span><br><span class="line">var content = '404 Not Found';</span><br><span class="line">}</span><br><span class="line">//响应请求</span><br><span class="line">response.write(content);</span><br><span class="line">response.end();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li>解决中文乱码<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//说明</span><br><span class="line">//nodejs作用：1-提供JS运行环境，2-提供N多模块(API)让JS更强大</span><br><span class="line"></span><br><span class="line">//1.创建http对象（引入node内置的http模块）</span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line">//2.创建http服务器（调用http对象的createServer）</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.监听用户请求（形参：request-请求对象，response-响应对象）</span><br><span class="line">server.on('request', function(request, response) {</span><br><span class="line"></span><br><span class="line">//响应请求</span><br><span class="line">response.setHeader('Content-Type', 'text/html; charset=utf-8');</span><br><span class="line">response.write("哥哥来抓我呀，&lt;a href='http://nn.com'&gt;点击进入我的世界&lt;/a&gt;");</span><br><span class="line">response.end();</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">//4.启动服务器</span><br><span class="line">server.listen(8080, function(){</span><br><span class="line">console.log('服务已启动，可以通过：http://localhost:8080 访问测试')</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-6请求和响应对象"><a href="#2-4-6请求和响应对象" class="headerlink" title="2.4.6请求和响应对象"></a>2.4.6请求和响应对象</h4></li><li>请求对象<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.headers     获取请求头信息（对象）</span><br><span class="line">req.rawHeaders 获取请求头信息（数组）</span><br><span class="line">req.httpVersion 获取HTTP版本</span><br><span class="line">req.method获取请求方法</span><br><span class="line">req.url         获取请求路径（注：不含网址）</span><br></pre></td></tr></tbody></table></figure></li><li>响应对象<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res.statusCode = 404;</span><br><span class="line">res.statusMessage = 'Not Found';</span><br><span class="line">res.setHeader（'Content-Type', 'text/html; charset=utf-8'）</span><br><span class="line"></span><br><span class="line">//简化版</span><br><span class="line">res.writeHeader(404, 'Not Found', {</span><br><span class="line">'Content-Type' : 'text/html; charset=utf8'</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">res.write（数据）</span><br><span class="line">res.end()</span><br></pre></td></tr></tbody></table></figure>（响应应查看mime类型）<h3 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h3></li><li>es6标签替换<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var html1=``;</span><br><span class="line">    msgs.forEach(function (items) {</span><br><span class="line">        html1+=`&lt;li class="list-group-item"&gt;${items.name}：${items.content} &lt;span class="pull-right"&gt;${items.create_at}&lt;/span&gt;&lt;/li&gt;`</span><br><span class="line"></span><br><span class="line">    })</span><br><span class="line">    lg.innerHTML=html1</span><br></pre></td></tr></tbody></table></figure></li><li>传统标签替换<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> var eleLi="";</span><br><span class="line">   for (var i=0;i&lt;msgs.length;i++){</span><br><span class="line"></span><br><span class="line">       eleLi+="&lt;li class='list-group-item'&gt;"+msgs[i].name+'说：'+msgs[i].content+" &lt;span class='pull-right'&gt;"+msgs[i].create_at+"&lt;/span&gt;&lt;/li&gt;"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   }</span><br><span class="line">lg.innerHTML=eleLi</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="切换NodeJS版本"><a href="#切换NodeJS版本" class="headerlink" title="切换NodeJS版本"></a>切换NodeJS版本</h2><ul><li><p>说明：通过nvm工具可以实现nodejs任意版本切换</p></li><li><p>下载：<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a> </p></li><li><p>命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nvm version</span><br><span class="line"></span><br><span class="line">nvm install  latest</span><br><span class="line"></span><br><span class="line">nvm install  版本号</span><br><span class="line"></span><br><span class="line">nvm uninstall 版本号</span><br><span class="line"></span><br><span class="line">nvm list</span><br><span class="line"></span><br><span class="line">nvm use   版本号</span><br></pre></td></tr></tbody></table></figure></li><li><p>安装nvm</p></li></ul><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps1.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps2.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps3.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps4.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps5.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps6.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps7.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps8.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps9.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps10.jpg" alt="img"> </p><ul><li>通过nvm查看托管nodejs版本  -&gt; 安装测试版 -&gt; 切换测试版 -&gt; 验证</li></ul><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps11.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps12.jpg" alt="img"> </p><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps13.jpg" alt="img"> </p><ul><li>切换稳定版 -&gt; 验证</li></ul><p><img src="file:///C:\Users\Hayabusa\AppData\Local\Temp\ksohtml4432\wps14.jpg" alt="img"> </p><p>解决nvm下载慢的问题</p><ol><li><p>命令行输入 where nvm</p></li><li><p>在提示目录下找到settings.txt</p></li><li><p>后面添加淘宝镜像：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01微信小程序介绍及环境准备</title>
      <link href="/2021/07/30/01-wei-xin-xiao-cheng-xu-jie-shao-ji-huan-jing-zhun-bei/"/>
      <url>/2021/07/30/01-wei-xin-xiao-cheng-xu-jie-shao-ji-huan-jing-zhun-bei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-微信小程序介绍"><a href="#1-微信小程序介绍" class="headerlink" title="1.微信小程序介绍"></a>1.微信小程序介绍</h2><p>微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可以使用的应用，它实现了应用“触手可及的梦想”，用户扫一扫或搜一下即可以打开应用。</p><h3 id="1-1为什么使用微信小程序"><a href="#1-1为什么使用微信小程序" class="headerlink" title="1.1为什么使用微信小程序"></a>1.1为什么使用微信小程序</h3><ol><li>微信有海量用户，而且黏性很高，在微信里开发产品更容易触达用户。</li><li>推广app或公众号成本太高。</li><li>开发适配成本低。</li><li>容易小规模是错，然后快速迭代。</li><li>跨平台。<h3 id="1-2微信小程序"><a href="#1-2微信小程序" class="headerlink" title="1.2微信小程序"></a>1.2微信小程序</h3>作者：张小龙</li><li>1.9正式上限。<h3 id="1-3不容忽视的其他微信小程序"><a href="#1-3不容忽视的其他微信小程序" class="headerlink" title="1.3不容忽视的其他微信小程序"></a>1.3不容忽视的其他微信小程序</h3></li><li>支付宝小程序</li><li>百度小程序</li><li>qq小程序</li><li>今日头条+抖音小程序</li></ol><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h2><p>开发微信小程序之前，必须准备好相应的环境。</p><h3 id="2-1注册账号"><a href="#2-1注册账号" class="headerlink" title="2.1注册账号"></a>2.1注册账号</h3><p><a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1&amp;token=&amp;lang=zh_CN">小程序注册</a></p><h3 id="2-2获取APPID"><a href="#2-2获取APPID" class="headerlink" title="2.2获取APPID"></a>2.2获取APPID</h3><h3 id="2-3开发工具"><a href="#2-3开发工具" class="headerlink" title="2.3开发工具"></a>2.3开发工具</h3><h2 id="10-常见组件"><a href="#10-常见组件" class="headerlink" title="10.常见组件"></a>10.常见组件</h2><p>小程序中常用的布局组件：<br><code>view,text,rich-text,button,image,navigator,icon,swiper,radio,checkbox.</code>等</p><h3 id="10-1view"><a href="#10-1view" class="headerlink" title="10.1view"></a>10.1view</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;&lt;view hover-class="h-class"&gt;</span><br><span class="line"> 点击我试试</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="10-2text"><a href="#10-2text" class="headerlink" title="10.2text"></a>10.2text</h3><ol><li>文本标签</li><li>只能嵌套text</li><li>长按文字可以复制（只有该标签有这个功能selectable）</li><li>可以对空格 回车进行编码(decode可以解析的有 &nbsp; &lt; &gt; &amp; '    )<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &nbsp;&lt;text selectable="{{false}}" decode="{{false}}"&gt;</span><br><span class="line"> &nbsp; 普&amp;nbsp;通</span><br><span class="line"> &nbsp;&lt;/text&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="10-3image"><a href="#10-3image" class="headerlink" title="10.3image"></a>10.3image</h3>好用的图床：<a href="https://qr.maitube.com/#pic%E6%88%96%E4%B8%83%E7%89%9B%E4%BA%91">https://qr.maitube.com/#pic或七牛云</a></li></ol><p><a href="https://m.360buyimg.com/mobilecms/s1350x1350_jfs/t3070/50/2589172055/70494/6e7056c5/57e3482aNa6324a7c.jpg!q70.dpg.webp">https://m.360buyimg.com/mobilecms/s1350x1350_jfs/t3070/50/2589172055/70494/6e7056c5/57e3482aNa6324a7c.jpg!q70.dpg.webp</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03php基础之环境搭建</title>
      <link href="/2021/07/30/03php-ji-chu-zhi-huan-jing-da-jian/"/>
      <url>/2021/07/30/03php-ji-chu-zhi-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02php基础之网站基本概念</title>
      <link href="/2021/07/29/02php-ji-chu-zhi-wang-zhan-ji-ben-gai-nian/"/>
      <url>/2021/07/29/02php-ji-chu-zhi-wang-zhan-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网站基本概念"><a href="#1-网站基本概念" class="headerlink" title="1.网站基本概念"></a>1.网站基本概念</h2><h3 id="1-服务器概念"><a href="#1-服务器概念" class="headerlink" title="1.服务器概念"></a>1.服务器概念</h3><p>​        服务器(server)，也称伺服器，是提供计算服务地设备，由于服务器需要相应服务请求，并进行处理，因此一般来说服务器应具备承担服务并保障服务的能力。<br>​        服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力，稳定性，可靠性，安全性，可扩展性，可管理性等方面要求较高。<br>​        在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，web服务器等。<br>服务器：能够提供服务的机器，取决于机器上安装的服务软件。<br>Web服务器：tomcat,jetty,iis等。</p><h3 id="2-IP概念"><a href="#2-IP概念" class="headerlink" title="2.IP概念"></a>2.IP概念</h3><p>​        IP: Internet Protocol,网络之间互联协议。网络之间互联的协议也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现像红心的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互联互通，IP地址具有唯一性。</p><h3 id="3-域名"><a href="#3-域名" class="headerlink" title="3.域名"></a>3.域名</h3><p>​        域名（Domain name）是由遗传用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名指带有行政自主权的一个地方区域），域名是一个IP地址的“面具”。一个域名的目的是便于记忆和沟通的一组服务器地址，域名作为力所能及难忘的互联网参与者的名称。<br>特殊ip:127.0.0.1 代表本机<br>特殊域名：localhost 代表本机</p><h3 id="4-DNS"><a href="#4-DNS" class="headerlink" title="4.DNS"></a>4.DNS</h3><p>​        DNS（Domain name system，域名系统），因特网上作为域名和ip地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住ip，通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><h3 id="5-端口"><a href="#5-端口" class="headerlink" title="5.端口"></a>5.端口</h3><p>​        端口（port）,可以认为是设备与外界通讯交流的出口，端口可以分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口；物理端口又称为接口，是可见端口，如计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。<br>端口用来区分服务。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01php基础之php简介</title>
      <link href="/2021/07/29/01php-ji-chu-zhi-php-jian-jie/"/>
      <url>/2021/07/29/01php-ji-chu-zhi-php-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="php简介"><a href="#php简介" class="headerlink" title="php简介"></a>php简介</h2><h3 id="什么是php"><a href="#什么是php" class="headerlink" title="什么是php"></a>什么是php</h3><p>​       php定义：一种服务器端的HTML脚本/编程语言，是一种简单的，面向对象的，解释型的，健壮的，安全的，性能非常之高的，独立于架构的，可移植的，动态的脚本语言，是一种广泛用于Open Source（开源）的尤其适合Web开发并可以嵌入HTML的多用途脚本语言。它的语法接近C，java和Perl,而且容易学习。该语言让Web开发人员快速的书写动态生成的网页。<br>php前身：Personal HomePage,个人主页，使用Perl语言开发的一种写个人主页的语言，<br>php:PHP Hypertext preprosessor,php超本文预处理器，底层使用c语言。</p><h3 id="PHP发展史"><a href="#PHP发展史" class="headerlink" title="PHP发展史"></a>PHP发展史</h3><p>Rasmus Lerdorf:创建者<br>平台支持（window,Linux,UNIX）<br>数据库支持（Sqlserver,mysql,Oracle,Access）</p><h3 id="静态网站与动态网站的区别"><a href="#静态网站与动态网站的区别" class="headerlink" title="静态网站与动态网站的区别"></a>静态网站与动态网站的区别</h3><p>静态网站：web1.0时代<br>动态网站：web2.0时代</p><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><p>​      website的中文名是网站，是指在互联网上，根据一定的规则，使用HTML、PHP等代码语言制作的用于展示特定内容的相关网页的集合，有可供管理人员操作的后台及用户使用的前台。简单地说，Webside是一种通讯工具，就像布告栏一样，人们可以通过 网站来发布自己想要公开的咨询，或者利用Website来提供相关的网络服务。人们可以通过网页浏览器来访问网站，获取自己现需要的咨询或者享受网络服务。</p><h4 id="静态网站的特点"><a href="#静态网站的特点" class="headerlink" title="静态网站的特点"></a>静态网站的特点</h4><p>​      1.网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；<br>​      2.静态网页的内容相对稳定，因此容易被搜索引擎检索；<br>​      3.静态网页没有数据库的支持；在网站制作和维护方面工作量较大，因此档网站信息量很大时完全依靠静态网页制作方式比较困难；<br>​      4.静态网页的交互性交叉，在功能方面有较大的限制；</p><h4 id="动态网站的特点"><a href="#动态网站的特点" class="headerlink" title="动态网站的特点"></a>动态网站的特点</h4><p>​      1.交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流地桥梁，动态网页地交互性也是今后web发展地潮流。<br>​      2.自动更新：即无须手动更新HTML文档，便会自动生成新页面，可以大大节省工作量。<br>​      3.因时因人而变：即当不同时间、不同用户访问同一网址会出现不同地信息。<br>​      此外动态网页是与静态网页相对应地，也就是说，网页URL的后缀不是.htm,html,shtml,xml等静态网页常见形式，而是以.asp，jsp,php,perl,cgi等为形式为后缀，在动态网页网址中有一个标志地符号–”?”。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语音转文字服务推荐与简单使用</title>
      <link href="/2021/07/27/yu-yin-zhuan-wen-zi-fu-wu-tui-jian-yu-jian-dan-shi-yong/"/>
      <url>/2021/07/27/yu-yin-zhuan-wen-zi-fu-wu-tui-jian-yu-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="1-服务"><a href="#1-服务" class="headerlink" title="1.服务"></a>1.服务</h2><h3 id="1-阿里云"><a href="#1-阿里云" class="headerlink" title="1.阿里云"></a>1.阿里云</h3><p>进入阿里云&gt;搜索产品（智能语音交互）&gt;选择个性化人声定制&gt;定制声音即可。<br>链接:<a href="https://nls-portal.console.aliyun.com/overview">个性化人声定制</a></p><h3 id="2-微软Azure"><a href="#2-微软Azure" class="headerlink" title="2.微软Azure"></a>2.微软Azure</h3><p>进入微软&gt;点击产品&gt;点击认知服务&gt;语音&gt;文本转语音。<br>链接：<a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/text-to-speech/?cdn=disable#overview">个性化人声定制</a></p><h2 id="2-好用的工具"><a href="#2-好用的工具" class="headerlink" title="2.好用的工具"></a>2.好用的工具</h2><h3 id="1-AI配音专家"><a href="#1-AI配音专家" class="headerlink" title="1.AI配音专家"></a>1.AI配音专家</h3><p>链接：<a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/text-to-speech/?cdn=disable#overview">AI配音专家</a><br>建议版本=v1.1.0<br>AccessKey ID=’LTAI5tCjZCecgfxbYTrktNpt’<br>AccessKey Secret=’eDX04dZrQ0XLCBIyVPpX4yDa1L17Na’<br>appkey = ‘9mPeplUpc60EzB3r’;</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式课程介绍</title>
      <link href="/2021/07/21/she-ji-mo-shi-ke-cheng-jie-shao/"/>
      <url>/2021/07/21/she-ji-mo-shi-ke-cheng-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1.设计模式概述"></a>1.设计模式概述</h2><h3 id="1-1软件设计模式的产生背景"><a href="#1-1软件设计模式的产生背景" class="headerlink" title="1.1软件设计模式的产生背景"></a>1.1软件设计模式的产生背景</h3><p>​       “设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><h3 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h3><p>​        软件设计模式（software design pattern），又称为设计模式，是一套被反复使用、多数人知晓、经过分类编目的、代码设计经验的总结。它描述了再软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一些列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h3 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h3><p>​        设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合欢喜的充分理解。<br>​        正确使用设计模式具有以下优点：  </p><ol><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，是软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。<h3 id="1-4设计模式分类"><a href="#1-4设计模式分类" class="headerlink" title="1.4设计模式分类"></a>1.4设计模式分类</h3></li><li>创建型模式<br>​       用于描述”怎样创建对象“，它的主要特点是”将对象的创建和使用分离“。GOF(四人组)书中提供了单例、原型、工厂方法、抽象工厂、建造者等5种创建型模式。</li><li>结构型模式<br>​       用于描述如何将类或对象按照布局组成更大的结构，GOF书中提供了代理、适配器、桥接、装饰、外观、享元、组合等7种结构型模式。</li><li>行为型模式<br>​       用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GOF书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为型模式。<h2 id="2-UML"><a href="#2-UML" class="headerlink" title="2.UML"></a>2.UML</h2>​      统一建模语言（unified modeling language,uml）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态和静态信息。<br>​       uml从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图。<h3 id="2-1类图概述"><a href="#2-1类图概述" class="headerlink" title="2.1类图概述"></a>2.1类图概述</h3>​       类图（class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。<h3 id="2-2类图的作用"><a href="#2-2类图的作用" class="headerlink" title="2.2类图的作用"></a>2.2类图的作用</h3>​       在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解。<br>​       类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。<h3 id="2-3类图表示法"><a href="#2-3类图表示法" class="headerlink" title="2.3类图表示法"></a>2.3类图表示法</h3><h4 id="2-3-1类的表示方式"><a href="#2-3-1类的表示方式" class="headerlink" title="2.3.1类的表示方式"></a>2.3.1类的表示方式</h4>​       在uml类图中，类使用包含类名、属性（field）和方法（method）且带有分割线的矩形来表示，比如下图表示一个employee类,它包含name,age和address这三个属性以及work（）方法。<br><img src="/medias/article/20210725/image-20210722224556025.png" alt="image-20210722224556025"><br>​      属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，uml类图中表示可见性的符号有三种：</li></ol><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected<br>​      属性的完整表示方式是：可见性 名称 ：类型 [=缺省值]<br>​      方法的完整表示方法是：可见性 名称（参数列表）[：返回类型]<blockquote><ul><li>中括号中的内容是可选的</li><li>也有将类型放在变量名前面，返回值类型放在方法名前面</li></ul></blockquote></li></ul><h4 id="2-3-2类与类之间关系的表示方式"><a href="#2-3-2类与类之间关系的表示方式" class="headerlink" title="2.3.2类与类之间关系的表示方式"></a>2.3.2类与类之间关系的表示方式</h4><h5 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h5><p>​      关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、丈夫与妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系，聚合关系和组合关系。<br>​      一般关联又可以分为单向关联，双向关联，自关联。</p><ol><li><p>单向关联<br><img src="/medias/article/20210725/image-20210722230359533.png" alt="image-20210722230359533"><br>​      在uml类图中单向关联用一个带箭头的实线表示。上图表示每一个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p></li><li><p>双向关联<br> <img src="/medias/article/20210725/image-20210722233858276.png" alt="image-20210722233858276"><br>​      在UML类图中，双向关联用一个不带箭头的直线表示。上图中在customer类中维护一个List<product>,表示一个用户可以购买多个商品，在product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</product></p></li><li><p>自关联</p></li></ol><p><img src="/medias/article/20210725/image-20210722234348752.png" alt="image-20210722234348752"><br>​     自关联在uml类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是”自己包含自己“。</p><h5 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h5><p>​      聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。<br>​      聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。<br>​      在UML类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><img src="/medias/article/20210725/image-20210723104522458.png" alt="image-20210723104522458"></p><h5 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h5><p>​      组合关系表示类之间的整体与部分的关系，但它十一种更强烈的聚合关系。<br>​      在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也不存在，部分对象不能脱离整体对象而存在。如头和嘴的关系，没有了头，嘴也就不存在了。<br>​      在UML类图中，组合关系用带实心零星的线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><img src="/medias/article/20210725/image-20210723104534564.png" alt="image-20210723104534564"></p><h5 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h5><p>​     依赖关系是一种使用关系，他是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法是通过局部变量，方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。<br>​     在UML类图中：依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：<br><img src="/medias/article/20210725/image-20210723105511797.png" alt="image-20210723105511797"></p><h5 id="2-3-2-5继承关系"><a href="#2-3-2-5继承关系" class="headerlink" title="2.3.2.5继承关系"></a>2.3.2.5继承关系</h5><p>​    继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。<br>​     在uml类图中，泛化关系用带空心三角箭头的实现来表示，箭头从子类指向父类。在代码实现时，使用面向对象的机制来实现泛化关系。例如，Student类和Teacher类都是Person类的子类，其类图如下所示：<br><img src="/medias/article/20210725/image-20210723114954142.png" alt="image-20210723114954142"></p><h5 id="2-3-2-6实现关系"><a href="#2-3-2-6实现关系" class="headerlink" title="2.3.2.6实现关系"></a>2.3.2.6实现关系</h5><p>​    实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。<br>​    在UML类图中，实现关系使用带空心三角建瓯的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下所示：<br><img src="/medias/article/20210725/image-20210723115455894.png" alt="image-20210723115455894"></p><h2 id="3-软件设计原则"><a href="#3-软件设计原则" class="headerlink" title="3.软件设计原则"></a>3.软件设计原则</h2><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h3 id="3-1开闭原则"><a href="#3-1开闭原则" class="headerlink" title="3.1开闭原则"></a>3.1开闭原则</h3><p>​     <strong>对扩展开放，对修改关闭。</strong>在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔效果。简言之，是为了使程序的扩展性好，易于维护和升级。<br>​     为了达到这样的效果，我们需要使用到接口和抽象类。<br>​     因为抽象类灵活性好，适应性广，只要抽象合理，可以基本保持软件架构的稳定，而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。<br>下面以<code>搜狗拼音输入法</code>皮肤为例介绍开闭原则的应用。<br>​     【例子】<code>搜狗拼音输入法</code>的皮肤设计。<br>​     分析：<code>搜狗拼音输入法</code>的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点可以为其定义一个抽象类（AbstractSkin)。而每个具体的皮肤（RyuHayabusaSkin）是其子类。用户窗体可以根据需要选择或增加新的主题，而需要修改原代码，所以它是满足开闭原则的。</p><p><img src="/medias/article/20210725/image-20210724221234379.png" alt="image-20210724221234379"></p><p>（注：图中搜狗输入法与抽象皮肤类之间的关系是聚合，画错了）</p><h3 id="3-2里氏代换原则"><a href="#3-2里氏代换原则" class="headerlink" title="3.2里氏代换原则"></a>3.2里氏代换原则</h3><p>​     里氏代换原则是面向对象设计的基本原则之一。<br>​     里氏代换原则：任何积累可以出现的地方。子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加心得方法完成新增功能外，尽量不要重写父类的方法。<br>​     如果通过重写父类的来完成新的功能，这样写起来虽然简单，但是整体继承体系的可复用性会比较差，或者是运用多态比较频繁时，程序运行出错的概率会比较大。<br>​     经典例子：<br>【例】正方形不是长方形<br>​     在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发一个几何图形相关的软件系统，可以顺理成章的让正方形继承自矩形。</p><p><img src="/medias/article/20210725/image-20210728234327425.png" alt="image-20210728234327425"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaee面试题</title>
      <link href="/2021/06/02/javaee-kao-qian-fu-xi-da-gang/"/>
      <url>/2021/06/02/javaee-kao-qian-fu-xi-da-gang/</url>
      
        <content type="html"><![CDATA[<h2 id="考点范围"><a href="#考点范围" class="headerlink" title="考点范围"></a>考点范围</h2><h3 id="1-http常见的状态码以及这些状态码的意义"><a href="#1-http常见的状态码以及这些状态码的意义" class="headerlink" title="1. http常见的状态码以及这些状态码的意义"></a>1. http常见的状态码以及这些状态码的意义</h3><blockquote><p>   <strong>2开头：（请求成功）表示成功处理了请求的状态代码</strong></p><ul><li>200：（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li><li>201：（已创建）请求成功并且服务器创建了新的资源</li><li>202：（已接受）服务器已接受请求，但尚未处理</li><li>203：（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一资源。</li><li>204：（无内容）服务器成功处理了请求，但没有返回任何内容</li><li>205：（重置内容）服务器成功处理了请求，但没有返回任何内容</li><li>206：（部分内容）服务器成功处理了部分 GET 请求</li></ul><p>   <strong>3开头：（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向</strong></p><ul><li>300：（多种选择）针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li><li>301：（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新的位置</li><li>302：（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303：（查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>304：（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页内容</li><li>305：（使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li><li>307：（临时重定向）服务器目前从不同位置的网页响应请求，但请求者继续使用原有位置来进行以后的请求</li></ul><p>   <strong>4开头：（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</strong></p><ul><li>400：（错误请求）服务器不理解请求的语法</li><li>401：（未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li><li>403：（禁止）服务器拒绝请求</li><li>404：（未找到）服务器找不到请求的网页</li><li>405：（方法禁用）禁用请求中指定的方法</li><li>406：（不接受）无法使用请求的内容特性响应请求的网页</li><li>407：（需要代理授权）此状态代码与 401 （未授权）类似，但指定请求者应当授权使用代理</li><li>408：（请求超时）服务器等候请求时发生超时</li><li>409：（冲突）服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息</li><li>410：（已删除）如果请求的资源已永久删除，服务器就会返回此响应</li><li>411：（需要有效长度）服务器不接受不含有效内容长度标头字段的请求</li><li>412：（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件</li><li>413：（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力</li><li>414：（请求的 URI 过长）请求的URI（通常为网址）过长，服务器无法处理</li><li>415：（不支持的媒体类型）请求的格式不受请求页面的支持</li><li>416：（请求范围不符合）如果页面无法提供请求的范围，则服务器返回此状态代码</li><li>417：（未满足期望值）服务器未满足“期望”请求标头字段要求</li></ul><p>   <strong>5开头：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</strong></p><ul><li>500：（服务器内部错误）服务器遇到错误，无法完成请求</li><li>501：（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li><li>502：（错误网关）服务器作为网关或代理，从上游服务器收到无效响应</li><li>503：（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态</li><li>504：（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505：（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本</li></ul></blockquote><h3 id="2-SpringBoot常用注解有哪些、"><a href="#2-SpringBoot常用注解有哪些、" class="headerlink" title="2. SpringBoot常用注解有哪些、"></a>2. SpringBoot常用注解有哪些、</h3><blockquote><p>   <strong>1、@SpringBootApplication</strong></p><p>   这个注解是Spring Boot最核心的注解，用在 Spring Boot的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。实际上这个注解是@Configuration,@EnableAutoConfiguration,@ComponentScan三个注解的组合。由于这些注解一般都是一起使用，所以Spring Boot提供了一个统一的注解@SpringBootApplication。</p><p>   <strong>2、@EnableAutoConfiguration</strong></p><p>   允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p><p>   如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。</p><p>   @EnableAutoConfiguration实现的关键在于引入了AutoConfigurationImportSelector，其核心逻辑为selectImports方法，逻辑大致如下：</p><p>   　●　从配置文件META-INF/spring.factories加载所有可能用到的自动配置类；</p><p>   　●　去重，并将exclude和excludeName属性携带的类排除；</p><p>   　●　过滤，将满足条件（@Conditional）的自动配置类返回；</p><p>   <strong>3、@Configuration</strong></p><p>   用于定义配置类，指出该类是 Bean 配置的信息源，相当于传统的xml配置文件，一般加在主类上。如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><p>   <strong>4、@ComponentScan</strong></p><p>   组件扫描。让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p>   @ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring容器中。</p><p>   <strong>5、@Repository</strong></p><p>   用于标注数据访问组件，即DAO组件。</p><p>   使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><p>   <strong>6、@Service</strong></p><p>   一般用于修饰service层的组件</p><p>   <strong>7、@RestController</strong></p><p>   用于标注控制层组件(如struts中的action)，表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器；它是@Controller和@ResponseBody的合集。</p><p>   <strong>8、@ResponseBody</strong></p><p>   表示该方法的返回结果直接写入HTTP response body中</p><p>   一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p><p>   <strong>9、@Component</strong></p><p>   泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>   <strong>10、@Bean</strong></p><p>   相当于XML中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>   <strong>11、@AutoWired</strong></p><p>   byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。</p><p>   当加上（required=false）时，就算找不到bean也不报错。</p><p>   <strong>12、@Qualifier</strong></p><p>   当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用</p><p>   <strong>13、@Resource(name=”name”,type=”type”)</strong></p><p>   没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>   <strong>14、@RequestMapping</strong></p><p>   RequestMapping是一个用来处理请求地址映射的注解；提供路由信息，负责URL到Controller中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>   <strong>15、@RequestParam</strong></p><p>   用在方法的参数前面。</p><p>   @Transactional：事务注解</p></blockquote><h3 id="3-ArrayList集合Set集合的区别"><a href="#3-ArrayList集合Set集合的区别" class="headerlink" title="3. ArrayList集合Set集合的区别"></a>3. ArrayList集合Set集合的区别</h3><blockquote><p>   <strong><em>\</em>1.List*****</strong>*集合是有序存储*<strong>**</strong>*,Set*<strong>**</strong>*集合是无序存储。这里的有序和无序针对的是存储地址来说的。****</p><p>   <strong><em>\</em>2.List*****</strong>*可以存储重复的值，*<strong>**</strong>*Set*<strong>**</strong>*不可以存储重复的值.****</p></blockquote><h3 id="4-SpringBoot常见的场景启动器有哪些"><a href="#4-SpringBoot常见的场景启动器有哪些" class="headerlink" title="4. SpringBoot常见的场景启动器有哪些"></a>4. SpringBoot常见的场景启动器有哪些</h3><blockquote><p>   ##1. spring-boot-starter-parent（控制版本信息）</p><p>   ##2. spring-boot-starter-web</p><p>   ##3. spring-boot-starter-test</p><p>   ##4.mybatis-spring-boot-starter</p><p>   ##5. mysql-connector-java：</p></blockquote><h3 id="5-描述servlet的生命周期"><a href="#5-描述servlet的生命周期" class="headerlink" title="5. 描述servlet的生命周期"></a>5. 描述servlet的生命周期</h3><blockquote><p>   <strong><em>①当启动,请求第一次到达servlet资源的时候,这个servlet对象一旦被构建,那么会立即去调用init方法,并且只会调用1次.</em></strong></p><p>   ②service方法 - 负责接收和响应来自于客户端的请求和数据.</p><p>   ③当关闭容器的时候,在**<em>GC**</em>销毁这个servlet对象之前,会先调用destroy方法来进行一些收尾的工作.</p></blockquote><h3 id="6-Servlet中service方法和doGet方法以及doPost方法的使用场景"><a href="#6-Servlet中service方法和doGet方法以及doPost方法的使用场景" class="headerlink" title="6. Servlet中service方法和doGet方法以及doPost方法的使用场景"></a>6. Servlet中service方法和doGet方法以及doPost方法的使用场景</h3><blockquote><p>   <strong><em>推荐学习阶段直接使用service - 接受一切请求</em></strong></p><ol><li>doGet方法只能接受get请求,否则会抛出HTTP Status 405 - HTTP method POST is not supported by this URL</li><li>doPost方法只能post请求 - 否则会抛出HTTP Status 405 - HTTP method GET is not supported by this URL</li><li>service：可以处理get请求和post请求<br>doGet：只能处理get请求<br>doPost：只能处理post请求<br>当service方法存在时，不管是post请求，还是get请求，都会优先调用service方法进行处理<br>如果service不存在时，根据各自的请求方式对doGet方法和doPost方法进行调用</li></ol></blockquote><h3 id="7-HttpServletRequest和HttpResponse以及ServletConfig三者的作用"><a href="#7-HttpServletRequest和HttpResponse以及ServletConfig三者的作用" class="headerlink" title="7. HttpServletRequest和HttpResponse以及ServletConfig三者的作用"></a>7. HttpServletRequest和HttpResponse以及ServletConfig三者的作用</h3><blockquote></blockquote><h3 id="8-Tomcat和Nginx服务器的默认端口号分别是什么"><a href="#8-Tomcat和Nginx服务器的默认端口号分别是什么" class="headerlink" title="8. Tomcat和Nginx服务器的默认端口号分别是什么"></a>8. Tomcat和Nginx服务器的默认端口号分别是什么</h3><blockquote><p>   8080     N:80</p></blockquote><h3 id="9-Http协议是什么-Http的结构是什么"><a href="#9-Http协议是什么-Http的结构是什么" class="headerlink" title="9. Http协议是什么?Http的结构是什么?"></a>9. Http协议是什么?Http的结构是什么?</h3><blockquote><p>   http(Hypertext transfer protocol)超文本传输协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定</p><p>   协议版本 + 状态码 + 用于解释状态码的原因短语 + 可选的响应首部字段 + 实体主体</p><p>   <strong>请求行、请求头、请求体</strong></p></blockquote><h3 id="10-jsp九大内置对象有哪些"><a href="#10-jsp九大内置对象有哪些" class="headerlink" title="10. jsp九大内置对象有哪些"></a>10. jsp九大内置对象有哪些</h3><blockquote><pre><code>1. out - 输出内容到web网页2. **page - page作用域,生命周期 - 仅仅在当前页面中有效**3. **request - request作用域,HttpServletRequest对象.一次请求一次响应**4. **session - session作用域,一次会话期间,从浏览器打开 - 浏览器完全退出**5. **application - application作用域 - 对应servlet中的ServletContext作用域,从服务器启动 - 服务器关闭**6. response - 将所有的响应给客户端的信息全部封装到了这个对象中.7. config - 获取servlet的配置信息 - 对应servlet中的组件ServletConfig对象8. exception - 异常对象9. pageContext - 通过这个对象可以获取比如page,request,session,application,config等对象.</code></pre></blockquote><h3 id="11-servlet三大作用域分别是什么-它们的作用域范围是什么"><a href="#11-servlet三大作用域分别是什么-它们的作用域范围是什么" class="headerlink" title="11. servlet三大作用域分别是什么,它们的作用域范围是什么"></a>11. servlet三大作用域分别是什么,它们的作用域范围是什么</h3><blockquote><pre><code>**1.request**作用域：一次请求**2.session**　作用域：当前会话。ServletContext 作用域 - 从服务器启动 - 服务器关闭</code></pre></blockquote><h3 id="12-如何防止表单重复提交"><a href="#12-如何防止表单重复提交" class="headerlink" title="12. 如何防止表单重复提交"></a>12. 如何防止表单重复提交</h3><blockquote><pre><code>1、禁掉提交按钮表单提交后使用 Javascript 使提交按钮disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效了。2、Post/Redirect/Get 模式在提交后执行页面重定向，这就是所谓的 Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。 3、在 session 中存放一个特殊标志当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。这使你的 web 应用有了更高级的 XSRF 保护。 4、使用Cookie处理使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单。 5、在数据库里添加约束在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。</code></pre></blockquote><h3 id="13-什么是cookie-有什么特点"><a href="#13-什么是cookie-有什么特点" class="headerlink" title="13. 什么是cookie,有什么特点"></a>13. 什么是cookie,有什么特点</h3><blockquote><pre><code>ookie是存储于访问者计算机中的变量 cookie是浏览器提供的一种机制 可以由JavaScript对其进行控制(设置、读取、删除)**简单但功能强大****跟踪cookie检测****安全数据删除****全面的cookie控制**（1）cookie可能被禁用； （2）cookie与浏览器相关，不能互相访问； （3）cookie可能被用户删除； （4）cookie安全性不够高； （5）cookie存储空间很小(只有4–10KB左右)</code></pre></blockquote><h3 id="14-什么是session-使用方式"><a href="#14-什么是session-使用方式" class="headerlink" title="14. 什么是session,使用方式"></a>14. 什么是session,使用方式</h3><blockquote><pre><code>当用户请求来自应用程序的 Web页时，服务器会给每一个用户（浏览器）创建一个Session对象；在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中；当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去，默认情况下，只要浏览器没有关闭，这个Session就一直存在。</code></pre></blockquote><h3 id="15-SpringBoot优势有哪些"><a href="#15-SpringBoot优势有哪些" class="headerlink" title="15. SpringBoot优势有哪些"></a>15. SpringBoot优势有哪些</h3><blockquote><pre><code># **更快速的构建能力**# **起步依赖**# **内嵌容器支持**# **Actuator 监**控非常简洁的安全策略集成支持关系数据库和非关系数据库支持运行期内嵌容器，如 Tomcat、Jetty强大的开发包，支持热启动自动管理依赖自带应用监控</code></pre></blockquote><h3 id="16-get请求和post请求有什么区别"><a href="#16-get请求和post请求有什么区别" class="headerlink" title="16. get请求和post请求有什么区别"></a>16. get请求和post请求有什么区别</h3><blockquote><pre><code>2） get是从服务器上获取数据，post是向服务器传送数据，一般用于更新资源信息3） get请求时通过URL直接请求数据，数据信息可以在URL中直接看到，比如浏览器访问；而post请求是放在请求头中的，我们是无法直接看到的4） get提交有数据大小的限制，一般是不超过2KB，而POST理论上默认是没有限制5） get请求因为数据参数是暴露在URL中的，所以安全性比较低，如密码不能暴露的就不能用get请求；post请求中，请求信息是放在请求头的，安全性较高，可以使用。&gt; 1. get请求 - 着重于去查询,请求参数的长度是有限制的&gt;    * 直接在浏览器中输入url&gt;    * 超链接的方式&gt;    * js按钮 - window.location&gt; 2. post请求 - 着重于去insert,update,delete - 请求参数的长度理论是没有限制的,二进制数据,安全&gt;    * form表单中的method设置成了post</code></pre></blockquote><h3 id="17-session和cookie有什么区别"><a href="#17-session和cookie有什么区别" class="headerlink" title="17. session和cookie有什么区别"></a>17. session和cookie有什么区别</h3><blockquote><pre><code>- **Cookie是把用户的数据写给用户的浏览器，由浏览器保存，可以保存多个**- **cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗**- **cookie的有效期在cookie生成的时候设置进去。**- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中  Session是把用户的数据写进用户独占的session中，服务器保存,登陆信息等重要信息存放入session  如果主要考虑到安全应当使用session ；  Session的有效期在web.xml配置文件里设置  </code></pre></blockquote><h3 id="18-转发和重定向有什么区别-以及代码是如何实现的"><a href="#18-转发和重定向有什么区别-以及代码是如何实现的" class="headerlink" title="18. 转发和重定向有什么区别,以及代码是如何实现的"></a>18. 转发和重定向有什么区别,以及代码是如何实现的</h3><blockquote><pre><code>##转发&gt; 地址栏的地址不变&gt;&gt; 一次请求,共享request作用域中数据&gt;&gt; 发生在服务器端的跳转##重定向&gt; 地址栏会变 -&gt;&gt; 控制台network - 出现俩次请求 - 不能获取到request作用域中的数据&gt;&gt; 本质:永远是拿着新的地址重新从客户端再次发送新的请求&gt;&gt; 发生在客户端的跳转转发：request.getRequestDispatcher("success.jsp").forward(request,response);               重定向：response.sendRedirect("success.jsp");</code></pre></blockquote><h3 id="19-反向代理和正向代理有什么区别"><a href="#19-反向代理和正向代理有什么区别" class="headerlink" title="19. 反向代理和正向代理有什么区别"></a>19. 反向代理和正向代理有什么区别</h3><blockquote><pre><code>**正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.****反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端**</code></pre></blockquote><h3 id="20-nginx的负载均衡策略有哪些"><a href="#20-nginx的负载均衡策略有哪些" class="headerlink" title="20. nginx的负载均衡策略有哪些"></a>20. nginx的负载均衡策略有哪些</h3><blockquote><pre><code>| 轮询               | 默认方式        || ------------------ | --------------- || weight             | 权重方式        || ip_hash            | 依据ip分配方式  || least_conn(待定)   | 最少连接方式    || fair（第三方）     | 响应时间方式    || url_hash（第三方） | 依据URL分配方式 |</code></pre></blockquote><h3 id="21-jstl中的c标签的使用-c-if-c-foreach等"><a href="#21-jstl中的c标签的使用-c-if-c-foreach等" class="headerlink" title="21. jstl中的c标签的使用 - c:if,c:foreach等"></a>21. jstl中的c标签的使用 - c:if,c:foreach等</h3><blockquote><pre><code>&lt;c:forEach var="u" items="${us}"&gt;&lt;tr&gt;&lt;td&gt;${u.uname}&lt;/td&gt;&lt;td&gt;${u.upsw}&lt;/td&gt;&lt;td&gt;${u.ugrant}&lt;/td&gt;&lt;td&gt;&lt;a href="edit?id=${u.id }" class="easyui-linkbutton" data-options="iconCls:'icon-reload'"&gt;更新&lt;/a&gt;&lt;/td&gt;&lt;c:if test="${u.uname!=uname}"&gt;&lt;td&gt;&lt;a href="delete?id=${u.id }&amp;uname=${u.uname}" οnclick="javascript:return del();" class="easyui-linkbutton" data-options="iconCls:'icon-remove'"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/c:if&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre></blockquote><h3 id="22-什么是多线程-什么是单例"><a href="#22-什么是多线程-什么是单例" class="headerlink" title="22. 什么是多线程,什么是单例"></a>22. 什么是多线程,什么是单例</h3><blockquote><pre><code>多线程，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</code></pre></blockquote><h3 id="23-Redis中的缓存穿透-击穿-雪崩是什么意思"><a href="#23-Redis中的缓存穿透-击穿-雪崩是什么意思" class="headerlink" title="23. Redis中的缓存穿透,击穿,雪崩是什么意思"></a>23. Redis中的缓存穿透,击穿,雪崩是什么意思</h3><blockquote><pre><code>**缓存雪崩：**缓存雪崩是指在设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，导致所有的查询都落在数据库上，造成了缓存雪崩。**缓存穿透：**缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。**缓存击穿：**对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</code></pre></blockquote><h3 id="24-解释MVC和MVVM思想"><a href="#24-解释MVC和MVVM思想" class="headerlink" title="24. 解释MVC和MVVM思想"></a>24. 解释MVC和MVVM思想</h3><blockquote><pre><code>MVC Model、View、Controller　　1）最上面的一层，是直接面向最终用户的"视图层"（View）。它是提供给用户的操作界面，是程序的外壳。　　2）最底下的一层，是核心的"数据层"（Model），也就是程序需要操作的数据或信息。　　3）中间的一层，就是"控制层"（Controller），它负责根据用户从"视图层"输入的指令，选取"数据层"中的数据，然后对其进行相应的操作，产生最终结果。 　那这样Model和View就是相互独立的。View只负责页面的展示，Model只是数据的存储，那么也就达到了解耦和重用的目的。 MVVM 双向数据绑定           mvvm是一种设计思想，M表示Model，V表示视图View，VM表示数据与模型（区别MVC中，C是用于跳转至哪个页面，而VM只是将数据进行转换或者封装）：           VM是mvvm模式的核心，它是连接view、model的桥梁。有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。           在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。</code></pre></blockquote><h3 id="25-集群-分布式-微服务三者之间的区别和联系"><a href="#25-集群-分布式-微服务三者之间的区别和联系" class="headerlink" title="25. 集群/分布式/微服务三者之间的区别和联系"></a>25. 集群/分布式/微服务三者之间的区别和联系</h3><blockquote><pre><code>（1）、分布式是以缩短单个任务的执行时间来提升效率，而集群则是通过提高单位时间内执行的任务数来提升效率；但分布式需要做好事务管理（2）、集群模式是不同服务器部署同一套服务对外访问，实现服务的负载均衡；区别集群的方式是根据部署多台服务器业务是否相同，分布式中的每个阶段，都可以做集群；而集群并不一定就是分布式的；注意：集群需要做好Session共享，也就是接口要具有无状态特征，确保在不同服务器切换的过程中不会因为没有获取到Session而引起服务终止（3）、分布式与微服务的架构很相似，只是部署方式不一样而已；生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的（4）、在设计与开发中我们可以将分布式与集群的分开吗？    分布式的主要功能是将我们的系统模块化，将系统进行解耦，方便维护和开发；但并不能解决系统的并发性和高可用性问题；而集群恰好弥补了分布式的缺陷，一方面可以解决或者说改善系统的并发问题，另一方可以解决服务器如果出现宕机后，系统仍然可以正常运转；好的设计应该是分布式和集群相结合，具体实现就是业务拆分成很多子业务，然后针对每个子业务进行集群部署。</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习之分布式系统定义</title>
      <link href="/2021/02/21/dubbo-xue-xi-zhi-fen-bu-shi-xi-tong-ding-yi/"/>
      <url>/2021/02/21/dubbo-xue-xi-zhi-fen-bu-shi-xi-tong-ding-yi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解两种加密方式中私钥和公钥的概念</title>
      <link href="/2021/02/09/li-jie-liang-chong-jia-mi-fang-shi-zhong-si-yao-he-gong-yao-de-gai-nian/"/>
      <url>/2021/02/09/li-jie-liang-chong-jia-mi-fang-shi-zhong-si-yao-he-gong-yao-de-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、两种加密方式"><a href="#一、两种加密方式" class="headerlink" title="一、两种加密方式"></a>一、两种加密方式</h2><h3 id="1-对称加密-私钥加密方法："><a href="#1-对称加密-私钥加密方法：" class="headerlink" title="1.对称加密_私钥加密方法："></a>1.对称加密_私钥加密方法：</h3><p>  私钥加密算法，又称 对称加密算法，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个<br>密钥是不能公开的。常见的有<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">《DES加密算法》</a>、<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/">《AES加密算法》</a>。</p><h3 id="2-不对称加密-公钥加密方法："><a href="#2-不对称加密-公钥加密方法：" class="headerlink" title="2.不对称加密_公钥加密方法："></a>2.不对称加密_公钥加密方法：</h3><p>  公钥和私钥成对出现</p><p>公开的密钥叫公钥，只有自己知道的叫私钥</p><p>用公钥加密的数据只有对应的私钥可以解密</p><p>用私钥加密的数据只有对应的公钥可以解密</p><p>如果可以用公钥解密，则必然是对应的私钥加的密</p><p>如果可以用私钥解密，则必然是对应的公钥加的密</p><p>公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。</p><h2 id="二、实现数据的安全传输"><a href="#二、实现数据的安全传输" class="headerlink" title="二、实现数据的安全传输"></a>二、实现数据的安全传输</h2><p>要实现数据的安全传输，当然就要对数据进行加密了。</p><p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用非对称算法，过程如下：</p><p>首先 接收方 生成一对密钥，即私钥和公钥；</p><p>然后，接收方 将公钥发送给 发送方；</p><p>发送方用收到的公钥对数据加密，再发送给接收方；</p><p>接收方收到数据后，使用自己的私钥解密。</p><p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p><h3 id="三、对信息进行数字签名"><a href="#三、对信息进行数字签名" class="headerlink" title="三、对信息进行数字签名"></a>三、对信息进行数字签名</h3><p>除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常“数字签名”是用来验证发送方的身份并帮助保护数据的完整性。</p><p>例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：</p><p>保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</p><p>保证信息自签发后到收到为止未曾作过任何修改。</p><p>之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。</p><h3 id="四、公钥算法的缺点"><a href="#四、公钥算法的缺点" class="headerlink" title="四、公钥算法的缺点"></a>四、公钥算法的缺点</h3><p>现实中，公钥机制也有它的缺点，那就是效率非常低，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法：</p><p>首先，发送方使用对称算法对原始信息进行加密。</p><p>接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。</p><p>接收方 将公钥发送给 发送方。</p><p>发送方用公钥对对称算法的密钥进行加密，并发送给接收方。</p><p>接收方用私钥进行解密得到对称算法的密钥。</p><p>发送方再把已加密的原始信息发送给接收方。</p><p>接收方使用对称算法的密钥进行解密。</p><p>  注：本文转载自<a href="https://songlee24.github.io/2015/05/03/public-key-and-private-key/">理解公钥与私钥</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从今天起我要开始更新自己的博客啦</title>
      <link href="/2021/02/03/ha-ya-bu-sa-de-di-yi-pian-bo-ke/"/>
      <url>/2021/02/03/ha-ya-bu-sa-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="哈雅布撒的第一篇博客"><a href="#哈雅布撒的第一篇博客" class="headerlink" title="哈雅布撒的第一篇博客"></a>哈雅布撒的第一篇博客</h2><blockquote><p>一个初级菜鸟程序员明志！_<br>努力！奋斗！ 2021-02-03</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
